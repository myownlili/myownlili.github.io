[{"title":"可以留言了！！！！","url":"/2020/06/29/20200629%E8%AE%B0/","content":"更新\n添加了留言功能，依托于Valine插件。大家多多评论哦，我好测试一下邮件 功能\n更换了主题颜色，发现了吗？这是中国色的一种哦\n去除了主页图片滤镜\n增加了背景的科技线条，高端大气上档次。我想拥有很久了待解决问题\n如何更改评论区样式？\n如何让主页轮播页面都拥有背景？\n如何让主页图片宽度减小？\n如何让界面更加美观？\n如何更改底栏显示？\n有无更加方便快捷的书写博文方式？\n怎么搞标签云？\n图床是什么？近日小记临近期末，很多地方都需要复习。但很烦躁，什么都不想做。复习效果不是很理想。不能再这样下去了！！！这学期结束再考虑写一些文档吧，专业实践是h5，有点期待。\n\n","categories":["日常"],"tags":["日常"]},{"title":"AS study-1","url":"/2020/09/11/AS-study-1/","content":"Android Studio 学习 Day1\n《第一行代码（Android)》第二版 第三章\n\n3.UI开发3.2 常见控件的使用TextView\n修改文字对齐方式android:gravity=&quot;center&quot;\n修改文字大小颜色android:textSize=&quot;24sp&quot;android:textColor=&quot;#065279&quot;\n\nButton\n系统会对text中的内容自动转换为大写，可任意禁用该属性\nandroid:textAllCaps=&quot;false&quot;\n注册监听器（匿名类）\nprotected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button =(Button)findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                //逻辑代码            &#125;        &#125;);    &#125;\n注册监听器（接口式）\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button = (Button) findViewById(R.id.button);        button.setOnClickListener(this);    &#125;    @Override    public void onClick(View v)&#123;        switch (v.getId())&#123;            case R.id.button:                break;            default:                break;        &#125;    &#125;&#125;\n\nEditText\n允许用户再控件李输入和编辑内容、并可以再程序中对这些内容进行处理。主要用于发短信、发微博、聊QQ等\n\n\n输入框中显示提示文字\nandroid:hint=&quot;Type something here&quot;/&gt;\n设置最大行数，多余的向上滚动\nandroid:maxLines=&quot;2&quot;\nEditText与Button结合\n实现效果：点击按钮获取EditText中输入内容\n\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    private EditText editText;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button = (Button) findViewById(R.id.button);        editText = (EditText)findViewById(R.id.edit_text);        button.setOnClickListener(this);    &#125;    @Override    public void onClick(View v)&#123;        switch (v.getId())&#123;            case R.id.button:                String inputText =editText.getText().toString();                Toast.makeText( MainActivity.this, &quot;inputText&quot;, Toast.LENGTH_SHORT).show();                break;            default:                break;        &#125;    &#125;&#125;\n\n","categories":["AS 学习"],"tags":["Android Studio"]},{"title":"AS-study-2","url":"/2020/09/14/AS-study-2/","content":"\nActivityTest:项目名\ncom.example.activitytest:包名（默认值）\n创建活动：com.example.activitytest-&gt;New-&gt;Activity-&gt;Empty Activity\nGenerate Layout File：自动创建一个对应的布局文件\nLauncher Activity:自动将**Acitivity设置为当前项目的主活动\n代码切换：\n\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;/LinearLayout&gt;\n\nsetContentView():给当前活动加载布局，一般要传入id,如R.layout.first_layout\nandroid:name指明具体注册的活动\n运行目标活动：在AndroidManifest.xm文件夹中，该活动的activity内添加intent-filter 标签，并在其中添加&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; 和&lt;category android: name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\nandroid:label指明活动中标题栏的内容，注：给著活动指定label也会成为启动器中应用程序的名称\n点击事件+Toast:\n\nprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.first_layout);    Button button1 = (Button) findViewById(R.id.button_1);    button1.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View v) &#123;            Toast.makeText(FirstActivity.this, &quot;You clicked Button 1&quot;,                Toast.LENGTH_SHORT).show();        &#125;    &#125;);&#125;\n\n\nfindViewById()方法获取在布局文件中定义的元素，然后返回一个View对象\nToast的用法非常简单，通过静态方法makeText() 创建出一个Toast 对象，然后调用show()将Toast显示出来就可以了。\n\n\n\n\n函数名\n参数\n\n\n\nmakeText()\n1.Context ，也就是Toast要求的上下文，由于活动本身就是一个Context 对象，因此这里直接传入FirstActivity.this 即可。\n\n\n\n2.Toast显示的文本内容\n\n\n\n3.Toast显示的时长，有两个内置常量可以选择Toast.LENGTH_SHORT 和Toast.LENGTH_LONG\n\n\n\n创建Menu资源文件：1.在res目录下创建menu文件夹(res-&gt;New-&gt;Directory-&gt;menu)             2.在menu文件夹创建main的菜单文件(menu-&gt;New-&gt; Menu resource file)\n\n\n添加菜单：在上一条的基础上的main.xml中添加雷士代码：\n\n&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/add_item&quot;        android:title=&quot;Add&quot;/&gt;    &lt;item        android:id=&quot;@+id/remove_item&quot;        android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt;\np66\n","categories":["AS 学习"],"tags":["Android Studio"]},{"title":"AS-study-3","url":"/2020/09/24/AS-study-3/","content":"四种基本布局1.线性布局(LinearLayout)\nandroid:layout_gravity：当LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。\nandroid:layout_weight:\n\n&lt;EditText      android:id=&quot;@+id/input_message&quot;      android:layout_width=&quot;0dp&quot;      android:layout_height=&quot;wrap_content&quot;      android:layout_weight=&quot;1&quot;      android:hint=&quot;type something&quot;/&gt;   &lt;Button       android:id=&quot;@+id/send&quot;       android:layout_width=&quot;wrap_content&quot;       android:layout_height=&quot;wrap_content&quot;       android:text=&quot;send&quot;/&gt;\n实验效果：\n2.相对布局(RelativeLayout)相对于父元素\n&lt;RelativeLayout android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;Button        android:id=&quot;@+id/button1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentLeft=&quot;true&quot;        android:layout_alignParentTop=&quot;true&quot;        android:text=&quot;button1&quot;/&gt;    &lt;Button        android:id=&quot;@+id/button2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentRight=&quot;true&quot;        android:layout_alignParentTop=&quot;true&quot;        android:text=&quot;button2&quot;/&gt;    &lt;Button        android:id=&quot;@+id/button3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:text=&quot;button3&quot;/&gt;    &lt;Button        android:id=&quot;@+id/button4&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_alignParentLeft=&quot;true&quot;        android:text=&quot;button4&quot;/&gt;    &lt;Button        android:id=&quot;@+id/button5&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_alignParentRight=&quot;true&quot;        android:text=&quot;button5&quot;/&gt;&lt;/RelativeLayout&gt;\n效果图：\n相对于控件\n&lt;Button    android:id=&quot;@+id/button3&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_centerInParent=&quot;true&quot;    android:text=&quot;button3&quot;/&gt;&lt;Button    android:id=&quot;@+id/button1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_above=&quot;@+id/button3&quot;    android:layout_toLeftOf=&quot;@id/button3&quot;    android:text=&quot;button1&quot;/&gt;&lt;Button    android:id=&quot;@+id/button2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_above=&quot;@id/button3&quot;    android:layout_toRightOf=&quot;@id/button3&quot;    android:text=&quot;button2&quot;/&gt;&lt;Button    android:id=&quot;@+id/button4&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_below=&quot;@id/button3&quot;    android:layout_toLeftOf=&quot;@id/button3&quot;    android:text=&quot;button4&quot;/&gt;&lt;Button    android:id=&quot;@+id/button5&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_below=&quot;@id/button3&quot;    android:layout_toRightOf=&quot;@id/button3&quot;     android:text=&quot;button5&quot;/&gt;\n效果图：\n帧布局(FrameLayout)&lt;FrameLayout android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;    &lt;TextView        android:id=&quot;@+id/text_view&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;left&quot;        android:text=&quot;This is TextView&quot;/&gt;    &lt;ImageView        android:id=&quot;@+id/image_view&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;right&quot;        android:src=&quot;@mipmap/ic_launcher&quot;/&gt;&lt;/FrameLayout&gt;\n效果图：\n百分比布局(略)","categories":["AS 学习"],"tags":["Android Studio"]},{"title":"Android Studio(2021.1.1)安装阿里云镜像","url":"/2022/03/23/Android%20Studio(2021.1.1)%E5%AE%89%E8%A3%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/","content":"作者最近下载了最新版Android Studio，习惯性的添加阿里云镜像。发现以往的教程都不适用了，自己摸索了一点方法，成功装上阿里云镜像。方法如下：\n\n步骤\n找到setting.gradle文件：\n添加如下代码，注意不同于以往的http要用https:\nmaven &#123;url &#x27;https://maven.aliyun.com/nexus/content/groups/public/&#x27;&#125;maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/google&#x27;&#125;maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;&#125;\n添加的位置如图，记得注释掉图中蓝框部分：\n效果点击右上角sync now\n成功啦！\n结论这个方法只能每个项目手动配置一遍… 作者还没探索出一劳永逸的方法T_T\n","categories":["AS"],"tags":["Android Studio"]},{"title":"CSS学习-day1","url":"/2020/08/20/CSS%E5%AD%A6%E4%B9%A0-day1/","content":"CSS3 圆角边框在 CSS3 中，border-radius 属性用于创建圆角：\ntext-align:center;/* 文字居中 */border:2px solid #a1a1a1;/* 边框样式 */padding:10px 40px; /* 上下左右间距 */background:#dddddd;/* 背景颜色*/width:350px;border-radius:25px;-moz-border-radius:25px; /* 老的 Firefox */\nCSS3 边框阴影在 CSS3 中，box-shadow 用于向方框添加阴影：\nbox-shadow: 10px 10px 5px #75878a;\n\nCSS3 边框图片\n边框图片\n\nCSS3 背景background-size 属性background-size:63px 100px;\n\nbackground-origin 属性\n背景属性\n\nCSS3 文本效果文本阴影水平阴影、垂直阴影、模糊距离，以及阴影的颜色\ntext-shadow: 5px 5px 5px #FF0000;\n字体加粗font-weight:bold;\n2D 转换translate() 方法通过 translate() 方法，元素从其当前位置移动，left（x 坐标） 和 top（y 坐标）：\ntransform:translate(50px,100px);\nrotate() 方法通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。\ntransform: rotate(2deg);\n\nscale() 方法宽度（X 轴）和高度（Y 轴）\n/* 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 */transform: scale(2,4);\n\nskew() 方法元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数\ntransform: skew(30deg,20deg);\n\nCSS3 多列column-count文本分为3列\ncolumn-count:3;\ncolumn-gap列之间的间隔：\ncolumn-gap:40px;\ncolumn-rule列之间的宽度、样式和颜色规则\ncolumn-rule:3px outset #ff0000;\n\n用户界面box-sizing规定两个并排的带边框方框\nbox-sizing:border-box;\noutline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。轮廓与边框有两点不同：轮廓不占用空间轮廓可能是非矩形\noutline-offset:15px;/*规定边框边缘之外 15 像素处的轮廓：*/","categories":["CSS学习"],"tags":["CSS","CSS3"]},{"title":"CSS学习-day2","url":"/2020/08/22/CSS%E5%AD%A6%E4%B9%A0-day2/","content":"id 选择器id 选择器以 “#” 来定义\nCSS背景背景色page&#123;    /* 全景背景色 */    background-color: blanchedalmond;&#125;\n.no1&#123;    background-color: blueviolet;    /* 设置内边距 */    padding: 20rpx;&#125;\nCSS 文本.no2&#123;    /* 文字缩进 */    text-indent: 2em;&#125;\n.no2&#123;    /* 文字悬挂 需要与padding-left配合使用*/    text-indent: -5em;     padding-left: 5em; &#125;\n.no3&#123;    /* 文字靠右 */    text-align: right;&#125;\n.no5&#123;    /* 字母间隔 */    letter-spacing: 20px;&#125;\ntext-transformnone 对文本不做任何改动，将使用源文档中的原有大小写。uppercase和lowercase 将文本转换为全大写和全小写字符。capitalize只对每个单词的首字母大写。\n.no5&#123;    /* 调整字母大小写 */    text-transform: uppercase;&#125;\ntext-decoration\nnone\nunderline:下划线\noverline:在文本的顶端画一个上划线\nline-through:则在文本中间画一个贯穿线\nblink: 会让文本闪烁\n\n.no5&#123;    text-decoration: underline overline;&#125;\n\nCSS 字体font-style\nnormal - 文本正常显示\nitalic - 文本斜体显示\noblique - 文本倾斜显示\n\n.no2&#123;    /* 文本倾斜 */    font-style:italic;&#125;\n\nbold字体加粗p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125;\n\nfont-size 属性设置文本的大小。.no4&#123;    font-size: 5px;&#125;","categories":["CSS学习"],"tags":["CSS"]},{"title":"CSS学习-day3","url":"/2020/08/24/CSS%E5%AD%A6%E4%B9%A0-day3/","content":"CSS 框模型\nCSS 内边距padding 属性定义元素的内边距\nview&#123;    /* 设置各边边距 */    padding: 50rpx;&#125;\n另一种设置方式\nview&#123;    /* 上、右、下、左 */    padding:10px 0.25em 2ex 20%;&#125;\n\nCSS 边框border-style\n\n\n\n值\n属性\n\n\n\nnone\n定义无边框。\n\n\nhidden\n与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。\n\n\ndotted\n定义点状边框。在大多数浏览器中呈现为实线。\n\n\ndashed\n定义虚线。在大多数浏览器中呈现为实线。\n\n\nsolid\n定义实线。\n\n\ndouble\n定义双线。双线的宽度等于 border-width 的值。\n\n\ngroove\n定义 3D 凹槽边框。其效果取决于 border-color 的值。\n\n\nridge\n定义 3D 垄状边框。其效果取决于 border-color 的值。\n\n\ninset\n定义 3D inset 边框。其效果取决于 border-color 的值。\n\n\noutset\n定义 3D outset 边框。其效果取决于 border-color 的值。\n\n\ninherit\n规定应该从父元素继承边框样式。\n\n\n定义单边样式：\nborder-style: solid solid none solid;\nview&#123;    /* 上、右、下、左 */    padding:10px 0.25em 2ex 20%;    border-style: outset;&#125;\n\n边框的宽度view&#123;    /* 边宽 */    border-width: 5px;&#125;\n定义单边宽度\nborder-width: 15px 5px 15px 5px;\n\n边框颜色border-color\nborder-color: blue rgb(96, 128, 162) #ffb3a7 red;\n\nCSS 外边距 marginmargin : 10px 5px 15px 5px;\n\n\nCSS position 属性\n\n\n值\n描述\n\n\n\nabsolute\n生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n\nfixed\n生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n\nrelative\n生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。\n\n\nstatic\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n\n\ninherit\n规定应该从父元素继承 position 属性的值。\n\n\n\n","categories":["CSS学习"],"tags":["CSS"]},{"title":"SpringBoot-1","url":"/2021/01/18/SpringBoot-1/","content":"永远的 Hello World!1. 首先创建一个项目2.编写一个服务器的类1.在src-main-java中新建一个package命名为com.swpu.controller2.在com.swpu.controller新建java class命名为MyAplication3.编写相关代码如下：\npackage com.swpu.controller;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//代表这个类是服务器类@SpringBootApplicationpublic class MyApplication &#123;    //定义一个启动方法    public static void main(String[] args) &#123;        SpringApplication.run(MyApplication.class,args);    &#125;&#125;\n\n1.src-main-resources中新建一个Directory命名为templates(改命名时框架中写死了的，不能更改)2.在templates文件夹中新建一个HTML file文件夹命名为helloworld3.编写相关代码如下：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello world!&lt;/body&gt;&lt;/html&gt;\n\n1.在com.swpu.controller新建java class命名为HelloWorldController2.编写相关代码如下：\npackage com.swpu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//这个类时与前端页面进行交互的类@Controller//可选注解非必须，用来定义这个类的映射地址,指浏览器访问这个类的地址@RequestMapping(&quot;/hello&quot;)public class HelloWorldController &#123;    //定义一个访问html页面的方法    //这个注解是必须的，访问该类的test方法    @RequestMapping(&quot;/test&quot;)    public String test() &#123;        //return 返回的是刚刚邂逅的页面前缀也就是页明        return &quot;helloworld&quot;;    &#125;&#125;\n对目录结构做一些更改！！！\n1.src-main-resources中新建一个file命名为application.properties2.编写相关代码如下,将数据库名和数据库密码换成自己的数据库名和数据库密码，由于本人使用的是MYSQL，所以数据库密码就是安装时设置的密码，数据库名可以 临时取一个。\nspring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = 数据库密码#控制台打印sqlmybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl","categories":["Spring Boot"],"tags":["Spring BOOt"]},{"title":"Hello World","url":"/2023/03/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"《计算机网络基础》复习1","url":"/2021/01/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E3%80%8B%E5%A4%8D%E4%B9%A01/","content":"第一章 计算机网络与因特网1.1 因特网的介绍1.1.1 因特网的构成\n主机或端系统 通过通信链路或分组交换机 连接到一起\n分组交换机有路由器和链路层交换机\n端系统通过因特网服务提供商ISP接入因特网\n协议控制因特网之间信息的接收和发送\n\n1.1.2 网络边缘和网络核心网络边缘：\n\n网络边缘：资源子网和接入网\n接入网：将端系统物理连接到边缘路由器的网络\n边缘路由器： 端系统到其他任何远程端系统的路径上的第一台路由器\n家庭接入：DSL、FTTH、电缆、拨号和卫星\n企业接入：以太网和WIFI\n广域无线接入：3G LTE\n\n\n\n网络核心：\n\n分组交换：分组以等于该链路最大传输速率的速度通过通信链路\n存储转发传输：在交换机能够能够开始向输出链路传输该分组的第一个比特前，必须接收整个分组\n排队时延和分组丢失：分组交换机具有输出缓存(输出队列)\n转发表和路由选择协议\n无连接，分组独立传输，逐端占用、存储与转发\n节点总时延 = 节点处理时延+排队时延+传输时延+传播时延\n\n\n电路交换 ： 预留端系统间沿路径通信所需要的资源（缓存、链路传输速率），如电话网络\n频分复用：FDM\n时分复用：TDM\n建连接，全程独占\n\n\n\n1.1.3 协议的概念协议：定义了在两个或多个通信实体间交换的报文格式和顺序，以及保温发送和/或接收一条报文或其他事件所采取的动作协议三要素：语法、语义、时序\n1.1.4 网络性能指标\n1.速率\n2.带宽\n3.吞吐量\n4.时延：节点总时延 = 节点处理时延+排队时延+传输时延+传播时延\n5.时延带宽积\n6.往返事件RTT\n7.利用率\n\n1.2 网络体系结构1.2.1 网络体系结构概念\n网络体系结构从功能上描述计算机网络结构\n各层及其协议的结合，各层功能及其关系的定义\n体系结构是抽象的\n\n1.2.2 对等层、服务与服务访问点\n实体：任何可发送或接收信息的硬件或软件进程\n协议是控制两个对等实体进行通信的规则的集合，协议是水平的\n任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是垂直的\n下层协议的实现对上层的服务用户是透明的\n同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP，交换原语，指定请求的特定服务。\n\n1.2.3 TCP/IP模型\n1.2.4 OSI/RM模型\n\n\nOSI七层原理模型\n\n\n\n应用层\n\n\n表示层\n\n\n会话层\n\n\n传输层\n\n\n网络层\n\n\n数据链路层\n\n\n物理层\n\n\n\n目的：支持异构网络系统的互联互通\n\n1.2.5 五层原理模型\n\n\n五层原理模型\n功能\n协议\n\n\n\n应用层\n支持各种网络应用\nFTP, SMTP, HTTP\n\n\n传输层\n进程-进程的数据传输\nTCP, UDP\n\n\n网络层\n源主机到目的主机的数据分 组路由与转发\nIP协议、路由协议等\n\n\n链路层\n相邻网络元素（主机、交换 机、路由器等）的数据传输\n以太网（Ethernet）、802.11 (WiFi)、 PPP\n\n\n物理层\n比特传输\n\n\n\n","categories":["计算机网络基础复习"],"tags":["计算机网络基础","复习"]},{"title":"《计算机网络基础》复习4","url":"/2021/01/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E3%80%8B%E5%A4%8D%E4%B9%A04/","content":"第四章 网络层4.1 网络层概述\n提供主机到主机的数据传输服务\n网络层应该具备什么功能？路由和分组转发\n为了标明网络中的路由，应该怎样标识网络中的节点？IP地址\n路由器根据路由表信息转发分组\n路由器根据路由协议和路由算法获得网络中的路由信息\n路由器根据下一个网络的链路层协议封装数据帧，从对应的端口发送出去来转发分组\n数据分片\n分片之后在目的主机重组\n\n4.1.1 网络层作用\n从发送主机向接受主机传送数据段\n发送主机：将数据段封装到数据报中\n接收主机：向传输层交付数据段\n每个主机和路由器都运行网络层协议\n路由器检验所有穿越它的IP数据报的头部域\n决策如何处理IP数据报\n\n\n\n4.1.2 网络层主要功能转发与路由\n\n路由协议确定通过网络的端到端路径，准发表确定在本路由器如何转发分组\n\n4.1.3 数据平面和控制平面概念数据平面：  \n    * 每个路由器都具备\n    * 决定输入端口到来的数据报怎样发送到输出端口\n    * 转发功能\n\n控制平面:\n    * 全网逻辑\n    * 确定数据报如何在路由器之间沿着从源主机到目的主机之间的路由转发\n    * 两种控制平面的方法：\n        * 传统路由算法：路由器中实现\n        * software-defined networking(SDN):远程服务实现\n\n每个路由器中独立的路由算法组件在控制平面中相互作用\n4.1.4 网络层服务类型无连接服务\n\n不事先为系列分组的传输确定传输路径\n每个分组独立确定传输路径\n不同分组可能传输路径不同\n数据报网络\n\n连接服务\n\n首先为系列分组的传输确定从源到目的经过的路径（建立连接）\n然后沿该路径（连接）传输系列分组\n系列分组传输路径相同\n传输结束后拆除连接\n虚电路网络 ：H1发送给H2的所有分组都沿着同一条虚电路发送\n\n4.2 IPv4协议4.2.1 IP协议作用\nIP协议：1.寻址规约\n    2.数据报（分组）格式\n    3.分组处理规约\n\n\nICMP协议：1.差错报告\n      2.路由器“信令”\n\n\n\n4.2.2 IP首部格式版本号：4位，IP协议的版本号首部长度：4位，以4字节位单位。e.g. 5-&gt;IP首部长度为20=5x4字节服务类型：8位总长度：16位，IP分组的总长度，首部+数据       最大IP分组的总长度：65535B       最小的IP分组首部：20B       IP分组可以封装的最大数据：65535-20=65515B生存事件TTL：8位，IP分组在网络中可以通过的路由器数（或跳步数）            路由器转发一次分组，TTL-1            如果TTL=0，路由器则丢弃该IP分组协议：8位，指示IP分组封装的是哪个协议的数据包        实现复用/分解        6为TCP,17为UDP首部校验和：16位，计算校验和时，该字段全置0            采用反码算数运算求和，和的反码作为首部校验和字段            逐跳计算、逐跳校验源IP地址、目的IP地址：各32位选项字段：长度可变，在1 ~ 40B之间，携带安全、源 选路径、时间戳和路由记录等内容填充字段：0~3B，即保证首部长度是4字节的倍数标识：16位，IP协议利用计数器，每产生IP分组计数器+1，作为该IP分组的标识标志位：3位，DF（Don’t Fragment),DF=1  禁止分片；MF（More Fragment) MF=1 非最后一片片偏移：13位，片品阿姨字段以8字节为单位\n4.2.3 IP分片与重组\n每段数据链路使用不同协议、不同长度\n\nMTU (最大传输单元)—链路层数 据帧可封装数据的上限\n4.2.4 IP地址概念接口：主机/路由器与物理链路的连接    实现网络层功能    路由器通常有多个接口    主机通常只有一个或两个接口（e.g. 有线的以太网接口，无线的802.11接口IP地址：32个比特(IPv4)网络号(NetID)-高位比特主机号（HostID)-低位比特IP子网：    IP地址具有相同网络号的设备接口    不跨越路由器可以彼此来连通的接口\nA类地址：NetID(0:8位)+HostID(24位) 0.0.0.0 ~ 127.255.255.255（01111111.1111111.11111111.11111111）B类地址：NetID(10:16位)+HostID(16位)128（1000 0000）.0.0.0 ~ 191（1011 1111）.255.255.255C类地址：NetID(110:24位)+HostID(8位)192（1100 0000）.0.0.0 ~ 223（1101 1111）.255.255.255D类地址：1110 224.0.0.0 ~ 239.255.255.255E类地址：1111 240.0.0.0 ~ 255.255.255.255\n私有IP地址\n\n\n\nclass\nNetIDs\nBlocks\n\n\n\nA\n10\n1\n\n\nB\n172.16 to 172.31\n32\n\n\nC\n192.168.0 to 192.168.255\n256\n\n\n4.2.5 子网划分（含变长子网）IP地址：\n\n网络号（NetID)-高位比特\n子网号（SubID)-原网络主机号部分比特\n主机号（HostID)-低位比特\n\n如何确定是否划分了子网？利用多少位划分子网？ 子网掩码子网掩码：有32位，点分十进制        取值：NetID、SubID位全取1            HostID位全取0        e.g. A网的默认子网掩码为：255.0.0.0             B类的默认子网掩码为：255.255.0.0             C类的默认子网掩码为：255.255.255.0             借用3比特划分子网的B网的子网掩码为：255.255.224.0\n\n4.2.6 CIDR与超网无类域间路由CIDR\n\nNetID+SubID-&gt;Network Prefix(Prefix)可以任意长度\n融合子网地址与子网掩码，方便子网划分。无类地址格式：a.b.c.d/x，其中x为前缀长度-------Prefix-----------  –HostID–11001000 00010111 0001000 000000000\n\n200.23.16.0/23\n\n子网201.2.3.64，255.255.255.192-&gt;201.2.3.64/26\n\nCIDR和超网\n\n提高IPv4地址空间分配效率\n提高路由效率\n将多个子网聚合为一个较大的子网\n构造超网（supernetting)\n路由聚合(route aggregation)\n\n\n\n4.2.7 路由转发分组原则\n路由算法确定去往目的网络的最佳路径\n转发表确定在本路由器如何转发分组\n\n4.3 路由算法4.3.1 控制平面两种实现方式\n传统路由算法：路由器中实现\n\nSDN：远程服务实现\n4.3.2 路由选择算法及其分类\n路由算法：寻找最小费用路径的算法\n\n分类：静态路由、动态路由\n\n静态路由：手工配置、路由更新慢、优先级高\n动态路由：路由更新快（定期更新、及时响应链路费用或网络拓扑变化\n\n\n全局信息和分散信息\n\n所有路由器掌握完整的网络拓扑和链路费用信息\ne.g. 链路状态(LS)路由算法\n\n\n分散信息\n\n路由器值掌握物理相连的邻居以及链路费用\n邻居间信息交换、运算的迭代过程\ne.g.距离向量（DV）的路由算法\n\n\n\n距离向量路由算法Bellman-Ford方程（动态规划）\n\n每个结点不定时地将其自身地DV估计发送给其邻居\n当x接收到邻居地新地DV估计时，即依据B-F更新其自身地距离向量估计: Dx(y)&lt;-minv{c(x,v)+Dv(y)}  for each node y belong to N\nDx(y)将最终收敛于实际地最小费用dx(y)\n异步迭代，引发每次迭代地因素：\n局部链路费用改变\n来自邻居DV更新\n\n\n分布式，每个节点只当DV变化时才通告给邻居\n\n4.3.3 ICMPICMP：互联网控制报文协议，支持主机或路由器、差错（或异常）报告、网络探寻两类ICMP报文：\n\n差错报告报文（5种）\n目的不可达\n源抑制\n超时/超期\n参数问题\n重定向\n\n\n网络探询报文\n回声请求与应答报文\n时间戳请求与应答报文\n\n\n\n\n几种不发送ICMP差错报告报文的特殊情况\n\n对ICMP差错报告报文不再发送ICMP差错报告报文\n除第1个IP数据报分片外，对所有后续分片均不发送ICMP差错报告报文\n对所有多播IP数据报均不发送ICMP差错报告报文\n对具有特殊地址（如127.0.00或0.0.0.0）的IP数据报不发送ICMP差错报告报文\n\n几种ICMP报文不再使用\n\n信息请求与应答报文\n子网掩码请求和应答报文\n路由器询问和通告报文\n\n\n停止准则：\n\nUDP数据报最终到达目的主机\n目的主机返回“目的端口不可达”ICMP报文（type=3,code=3)\n源主机停止\n\n4.3.4 OSPF概念：\n\n“开放”：公众可用\n采用链路状态路由算法\nLS分组扩散（通告）\n每个路由器构造完整地网络(AS)拓扑图\n利用Dijkstra算法计算路由\n\n\nOSPF通告中每个入口对应一个邻居\nOSPF通告在整个AS范围泛洪，OSPF报文直接封装到IP数据报中\n与OSPF极其相似地一个路由协议：IS-IS路由协议\n\n优点（RIP不具备）：\n\n安全：所有OSPF报文可以被认证（预防恶意入侵）\n允许使用多条相同费用地路径（RIP只能选一条）\n对于每条链路，可以针对不同地TOS设置在多个不同地费用度量\n集成单播路由与多播路由：\n多播OSPF协议(MOSPF)与OSPF利用相同地网络拓扑结构\n\n\nOSPF支持带大规模AS分层\n\n分层地OSPF：两极分层：局部区、主干区\n\n链路状态通告只限于区内\n每个路由器掌握所在区地详细拓扑结构\n只知道去往其他区网络的“方向”（最短路径）\n\n区边界路由器：“汇总”到达所在区网络的距离，通告给其他区边界路由器主干路由器：在主干区内允许OSPF路由算法AS边界路由算法：连接其他AS\n","categories":["计算机网络基础复习"],"tags":["计算机网络基础","复习"]},{"title":"《计算机网络基础》复习5","url":"/2021/01/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E3%80%8B%E5%A4%8D%E4%B9%A05/","content":"第五章 链路层和局域网5.1 数据链路层作用相邻节点之间传输帧为单位的数据相邻网络元素的数据传输（主机、交换机、路由器等）的数据传输\n链路层服务\n\n组帧\n封装数据报构成数据帧，加首部和尾部\n帧同步\n\n\n链路接入\n如果时共享介质，需要解决信道接入\n帧首部的MAC地址，用于标识帧的源和目的\n\n\n相邻结点间可靠交付\n在低码率的有线链路上很少采用（如光前，某些双绞线等）\n无线链路：误码率高，需要可靠较复\n\n\n差错检测\n信号衰减和噪声会引起差错\n接收端检测到差错\n\n\n差错纠正\n接收端直接纠正比特错误\n\n\n\n5.2 链路概念及其分类\n主机和路由器：结点\n连接相邻结点的通信信道：链路\n有线链路\n无线链路\n局域网\n\n\n链路层数据分组：帧，封装网络层数据报\n\n5.3 Mac协议、Mac地址MAC：多路访问控制协议\n\n点对点来链路\n拨号接入的PPP\n以太网交换机与主机间的点对点链路\n\n\n广播链路（共享介质）\n早期的总线以太网\nHFC的上行链路\n无线局域网\n\n\n\nMAC：\n\n采用分布式算法决定结点何如共享信道，即决策结点何时可以传输数据\n必须基于信道本身，通信信道共享协调消息\n无带外信道用于协调\n\n\n\nMAC地址\n\n32位IP地址\n接口的网络层地址\n用于标识网络层分组，支持分组转发\n\n\n又称LAN地址、物理地址、以太网地址\n作用：哦那个与局域网内识别一个帧是从那个接口发现胡，到达哪个物理连接的接口\n48位MAC地址(用于大部分LANs)，固化在网卡的ROM中，有时也可以软件设置\ne.g. : 1A-2F-BB-76-09-AD  (16进制表示)\n\n\n局域网中的每块网卡都有唯一的MAC地址\nMAC地址由IEEE统一管理与分配\n网卡生产商购买MAC地址空间（前24个比特）\nMAC地址是“平面地址”：可携带\n可以从一个LAN移到另一个LAN\n\n\nIP地址是层次地址：不可携带\n\nMAC协议分类：\n\n信道划分MAC协议\n\n多路复用技术\nTDMA：(time)\n“周期性”接入信道\n每个结点在每个周期，占用固定长度的时隙\n未用时隙空闲\n\n\nFDMA(frequency)\n信道频谱划分为若干频带\n每个站点分配一个固定频带\n无传输频带空闲CDMA\\WDMA\n\n\n\n\n随机访问MAC协议\n\n信道不划分，允许冲突\n采用冲突“恢复”机制（e.g. 延时重传）\n\n\n轮转MAC协议\n\n结点轮流使用通道\nCSMA/CD\n\n\n\n5.4 共享多路信道访问方法5.4.1 CSMA协议载波监听多路协议CSMA\n\n发送帧之前，监听信道（载波）\n信道空闲：发送完整帧\n信道忙：推迟发送\n\n\n冲突可能仍然发生 ：信号传播延迟\n继续发送冲突帧：浪费信道资源\n\n5.4.2 CSMA/CD协议Collsion Detection\n\n短时间内可以检测到冲突\n冲突后传输中止，减少信道浪费\n冲突检测\n有线局域网易于实现:测量信号强度，比较发射信号与接收信号\n无线局域网很难实现：接收信号强度淹没在本地发射信号强度下\n\n\n\n边发边听，不发不听**5.5 局域网与以太网\n\n\n*局域网**：LAN，是一个地址范围小的计算机网络。计算机网络的一个分支\n*特点**：\n地理范围小：几公里\n使用多路访问协议：如CSMA/CD\n数据传输率R高：10Mb/s、100Mb/s、1Gb/s、10Gb/s\n单位拥有\n\n局域网拓扑结构\n局域网协议标准IEEE 802.3 CSMA/CD以太网以太网\n\n“统治地位”的有线LAN技术\n\n\n造价低廉\n应用最广泛的LAN技术\n比令牌局域网和ATM等，简单、便宜\n满足网络速率要求 10 Mbps – 10 Gbps\n\n以太网物理拓扑\n\n总线：所有结点在同一冲突域\n星型：主流网络拓扑\n中心交换机\n每个结点一个单独冲突域\n\n\n\n以太网不可靠、无连接的服务\n\n无连接：发送帧的网卡与接收帧的网卡间没有握手过程\n不可靠：接收网卡不向发送网卡进行确认\n差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（e.g.TCP）否则，发生数据丢失\n\n\n以太网的MAC协议：采用二进制指数退避算法的CSMA/CD\n\n5.6 交换机工作原理、地址学习5.7 交换式以太网特点5.8 ARP交换式以太网特点ARP：地址解析协议ARP表：LAN中每个IP结点（主机、路由器）维护一个表\n\n存储某些LAN结点的IP/MAC地址映射关系：&lt;IP地址；MAC地址；TTL&gt;\n\n\nTTL：经过这个时间以后该映射关系被遗弃（典型值为20min)\n\n5.9 分组在链路层转发过程\n在同一个LAN中，发送ARP请求分组即可\n在不同LAN中：\nA-&gt;R:(ip dest:B) (ip src:A)  (mac dest： R左) (mac src:A)\nR :提取IP数据报，传递给上层IP协议\nR 转发IP数据报（源和目的IP地址不变）R 创建链路层帧：（mac src:R右）（mac dest :B)\n\n\n\n","categories":["计算机网络基础复习"],"tags":["计算机网络基础","复习"]},{"title":"【JavaGuide】Java基础常见知识和面试题总结（上）","url":"/2022/03/24/%E3%80%90JavaGuide%E3%80%91Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E5%92%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程\nJava基础常见知识&amp;面试题总结(上)\n基础概念和常识JVM VS JDK VS JRE自我理解20220324\nJVM：能运行java程序的平台， 每个人、公司都可以自己开发，不同的JDK（？）对应不同的JVM版本JDK：包含java运行所需的各种SDK、以及一些相关文件。jdk包含JRE拥有的一切JRE：包括java虚拟机等java需要的运行工具，如果只需要运行java程序，指安装JRE即可。如果需要编辑java 程序就需要安装JDK。在运行web程序的时候也需要安装JDK，因为什么呢（某种转化）\n官方理解\nJVM：运行java字节码的虚拟机，有针对不同系统的特定实现。各个版本的JDK对应不同的JVM规范JDK：java development kit的缩写，=JRE+编译器(javac)+工具(javadoc+jdb)。可以创建和编译程序JRE：是java运行环境，=JVM+java类库+java命令+其他基础构建。使用JSP部署web应用的时候，应用程序服务器会将JSP转换为java servelt，并且需要使用JDK来编译servelt\n\n\n什么是字节码？采用字节码的好处是什么？自我理解20220324\n代码就是字节码，使java能够在各个平台编译也能得到相同的结果。java程序的编译过程：java程序-&gt;javac-&gt;.class文件-&gt;解释器+JIT-&gt;机器码-&gt;os.class文件需要翻译成机器码才可以运行，翻译过程很耗时，于是需要JIT辅助。有一部分代码会被经常使用，称之为热代码，JIT(just-in-time)就是记录这部分代码，提升每次解释代码的速度。java9版本加入了AOT，可以提前将热代码的翻译存储起来，但是这样效果没有JIT好\n官方理解\n\nJVM可以理解的代码叫字节码（扩展名为.class的文件），只面向虚拟机，保留了解释型语言可移植的特点JIT属于运行时编译。当JIT完成第一次编译后，会将字节码对应的机器码保存下来，下次直接使用JDK 9引入的AOT(Ahead of Time Compilation),JDK支持分层编译和AOT\n\n\n为什么说Java语言“编译和解释共存”自我理解20220324\n编译型：通过编译器一次性编译成机器可以理解的代码（有C\\C++）解释型：通过解释器一句句翻译成机器码（有JavaScript)java先编译成.class文件，后翻译成机器码，所以说是编译和解释共存\n官方理解\n\n编译型：执行速度快、开发效率低。有C\\C++\\GO\\Rust解释型：执行速度较慢、开发效率高。有python\\javascript\\PHP\n\n\nOracle JDK vs Open JDK自我理解20220324\n就是Oracle JDK是基于OpenJDK开发的，但是又更多的类、更加的稳定，但是不开源。个人使用均免费，商用建议采用Oracle JDK。\n官方理解\n比较简单，直接贴文字：\n\n Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadenceopen in new window 。\nOpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；\nOracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；\n在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；\nOracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；\nOracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。\n\n\n\nJava和C++的区别自我理解20220324\nJava单继承、C++多继承Java不提供操作符重载\n官方理解\n如下\n\njava不提供指针直接访问内存\n类不能多继承，但是接口可以\njava有自动内存管理垃圾回收机制GC\njava只指出方法重载\n\n\n\n基本语法字符型常量和字符串型常量的区别自我理解20220325\n\n字符型常量用单引号引起来，’a’,’b’;字符串型常量用双引号引起来，”12345678”\n字符型常量可以赋值，字符串型常量只代表字符串的地址\n\n官方理解\n含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表地址值占内存大小：字符常量占两个字节，字符串常量占若干个字节\n\n\n注释有哪几种形式自我理解2022-03-25\n\n单行注释 //\n多行注释   /***/\n文档注释 /** ***/\n\n官方理解\n1.单行注释2.多行注释3.文档注释\n\n\n标识符和关键字的区别是什么自我理解2022-03-25\njava编写过程中的类、方法都需要一个名字，这就是标识符。但有些标识符有其特定的意义，这就是关键字\n官方理解\n比较简单直接贴文字：在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 标识符 。简单来说， 标识符就是一个名字 。有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，关键字是被赋予特殊含义的标识符 。\n\n\nJava语言关键字有哪些自我理解2022-03-25\n\n访问控制：privite\\protected/public\n类，方法和变量修饰符：abstract\\extends\\final (class\\new\\static\\strctfp\\synchronized)\n程序控制 ：swtich\\continue\\break(return\\do\\for\\instanceof\\case)\n错误处理：catch\\throw\\throws\\try\n包相关：impact\\package\n基本类型：const (boolean\\byte\\char\\double\\short)\n变量引用：void (super\\this)\n保留字：goto (const)\n\n官方理解\n\n\n分类\n关键字\n\n\n\n\n\n\n\n\n\n——————–\n——–\n———\n——–\n————\n———-\n———-\n——\n\n\n访问控制\nprivate\nprotected\npublic\n\n\n\n\n\n\n类，方法和变量修饰符\nabstract\nclass\nextends\nfinal\nimplements\ninterface\nnative\n\n\n\nnew\nstatic\nstrictfp\nsynchronized\ntransient\nvolatile\nenum\n\n\n程序控制\nbreak\ncontinue\nreturn\ndo\nfor\ninstanceof\nswitch\n\n\n\nwhile\nif\nelse\ncase\ndefault\nassert\n\n\n\n错误处理\ntry\ncatch\nthrow\nthrows\n\n\n\n\n\n包相关\nimport\npackage\n\n\n\n\n\n\n\n基本类型\nboolean\nbyte\nchart\ndouble\nfloat\nint\nlong\n\n\n\nshort\n\n\n\n\n\n\n\n\n变量引用\nsuper\nthis\nvoid\n\n\n\n\n\n\n保留字\n\ngoto\nconst\n\n\n\n\n\n\n\n注意 ⚠️：最然true，false，null看起来像关键字但实际上他们是字面值，但你不能把他们当标识符用\n\n\n自增自减运算符自我理解2022-03-25\n有一些整形变量+1、-1的需求，java提供了++、--两种运算符b=a++：意味着先把a的值赋给b，再让a +1。输出的结果就是ab=++a：意味着a的值先+1，再把+1后的值赋给b。输出结果为a+1\n官方理解\n ++就是自增运算符--就是自减运算符\n\n\ncontinue、break和return的区别是什么？自我理解2022-03-25\n\ncontine：跳出当前循环、进入下一循环\nbreak：跳出整个循环\nreturn：跳出这个方法。return;表示无返回值跳出，return XX;表示有返回值跳出\n\n官方理解public static void main(String[] args) &#123;        boolean flag = false;        for (int i = 0; i &lt;= 3; i++) &#123;            if (i == 0) &#123;                System.out.println(&quot;0&quot;);            &#125; else if (i == 1) &#123;                System.out.println(&quot;1&quot;);                continue;            &#125; else if (i == 2) &#123;                System.out.println(&quot;2&quot;);                flag = true;            &#125; else if (i == 3) &#123;                System.out.println(&quot;3&quot;);                break;            &#125; else if (i == 4) &#123;                System.out.println(&quot;4&quot;);            &#125;            System.out.println(&quot;xixi&quot;);        &#125;        if (flag) &#123;            System.out.println(&quot;haha&quot;);            return;        &#125;        System.out.println(&quot;heihei&quot;);    &#125;\n\n\n运行结果\n0xixi12xixi3haha\n\n\n\n方法自我理解2022-03-25\n什么是方法的返回值?方法有哪几种类型？\n方法执行代码后得到的结果，用返回值来接收。并不是所有的方法都需要传入参数，也不是所有的方法都有返回值\n静态方法和实例方法的不同\n\n调用方式不同。静态方法可以用类名.方法名，以及对象名.方法名。实例方法只能用对象名.方法名。一般不建议调用静态方法用对象名.方法名，容易混淆。(调用静态方法无需创建对象)\n用对象不同 。静态方法只能调用静态成员、以及静态变量。实例方法就没有这个限制。(访问类成员是否存在限制？ 静态方法再访问本类的成员时，只允许访问静态成员，即静态成员白能量和限制方法，不允许访问实例成员)\n\n重载和重写的区别\n\n重载就是子类与父类，方法名相同，传参列表、返回结果可以不同。计算机再编译时自动寻找更合适的方法，找不到就返回错误，称为重载解析，java可以重载任何方法。\n重写就是“两同两小一大”，子类和父类的方法名和传参列表必须一致，子类的返回值和 (方法申明抛出的异常类) 异常类必须小于或接近父类的范围，子类可以降低父类访问控制的限制。java不能重写构造方法。(如果方法的返回类型是void和基本数据欸i选哪个，则返回重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类)\n(重写：如果父类方法访问修饰符为private/fianl/static则子类不能重写该方法，但是被static修饰的方法能够被再次声明)\n\n官方理解1. 无参数无返回值的方法\npublic void f1() &#123;    //......&#125;// 下面这个方法也没有返回值，虽然用到了 returnpublic void f(int a) &#123;    if (...) &#123;        // 表示结束方法的执行,下方的输出语句不会执行        return;    &#125;    System.out.println(a);&#125;\n\n2. 有参数无返回值的方法\npublic void f2(Parameter 1, ..., Parameter n) &#123;    //......&#125;\n\n3. 有返回值无参数的方法\npublic int f3() &#123;    //......    return x;&#125;\n\n4. 有返回值有参数的方法\npublic int f4(int a, int b) &#123;    return a * b;&#125;\n\n\n\n\n\n区别点\n重载方法\n重写方法\n\n\n\n发生范围\n同一个类\n子类\n\n\n参数列表\n必须修改\n一定不能修改\n\n\n返回类型\n可修改\n子类方法返回值类型应比父类方法返回值类型更小或者相等\n\n\n异常\n可修改\n子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等\n\n\n访问修饰符\n可修改\n一定不能做更严格的限制（可以降低限制）\n\n\n发生阶段\n编译期\n运行期\n\n\n\n= =和equals()的区别自我理解2022-03-26\n\n= =在基本数据类型中是比较两个对象的值，在引用数据类型中使用，就是比较两个对象的地址。由于java只对值进行比较，所以本质上还是比较两个对象的值。\nequals()。equals()类 (方法) 在object类中，object类在间接或直接上是所有类的父类，所以所有类的包含equals()类 (方法)。\nequals类重写和不重写是有区别的。不重写就类似= =，用来比较两个变量的值。重写就是是比较两个对象的属性等等各个方面。比如string类的equals()就是重写过的。\n\n官方理解\n\n= = java只有值传递，只是引用类型变量存的值是对象的地址\nequals()不能用来判断基本数据类型的变量，只能用来比较两个对象是否相等\n类没有重写equals()方法：通过equals()比较两个对象，等同于= = ，使用默认Object类的equals()方法。\n类重写了equals()方法：一般我们都重写equals()方法来比较两个对象的属性是否相等；若相等，返回true。String中equals()方法是重写的，用来比较对象的值。Object类的equals()方法是比较的对象的内存地址。\n\n\n\nhashCode()与equals()自我理解2022-03-26\n一个对象经过hashCode()处理后，得到其hash值。可以确定该对象和其他hash值不同的对象肯定是不同的，接下来就要用equals()来对hash值相同的对象进行比较，如果发现还是不同，则就是真的不同。如果相同，就不需要把本对象放进hashset中。所以重写equals()方法，也要同时重写hashCode方法。\n官方理解\nhashCode()的作用是获取哈希码(int整数)，也称散列码。这个哈希码的作用是确定该对象的哈希码的索引位置。hashCode()定义在JDK的Object类中。两个相等的对象的hashCode值必须是相等。HashSet通过计算对象hashCode值来判断对象加入的位置，同时和已加入对象的hashCode值惊醒比较，如果没有重复的，HasnSet假定对象没有城府出现。如果有相同hashCode值的对象，就调用equals()方法来检查是否真的相同。如果完全相同，就不会让其加入成功。如果不同的话，就会重新散列到其他位置。——《Head First Java》\n\n\n什么是可变长参数自我理解2022-03-26\njava5之后允许传入0个或多个参数，(遇到重载时)系统会优先匹配固定参数的方法，然后才是可变长参数的方法。格式如下：\npublic static void printVarible(String... args)&#123;\t//...&#125;\n\n官方理解\n\nJava5开始支持定义可变长参数，所谓可变长参数就是在调用方法时传入不定长参数。\n另外,可变长参数只能作为函数的最后一个参数，但其前面可以有也可以没有其他任何参数。\nJava的可变长参数百衲衣后实际会被转换成一个数组，可以通过class文件看出来。\n\n\n\n基本数据类型Java基本数据类型了解吗自我理解2022-03-28\nJava有8种基本数据类型：\n\n数值型  (数字类型):\n整数数据类型：byte/short/int/long\n浮点数类型：float/double\n\n\n字符类型：char\n布尔类型：boolean\n\njava的long型数据后面要加L，方便虚拟机辨认  (否则将作为整型解析)。8种基本数据类型对应的包装型数据变量 (包装类)是Byte/Short/Intager (Integer)/Long/Float/Double/Charater (Character)/Boolean包装型数据变量的默认值是Null。\nbyte  1字节 8位short 2字节 16位…\n官方理解\n\n\n基本类型\n位数\n字节\n默认值\n取值范围\n\n\n\nbyte\n8\n1\n0\n-128~127\n\n\nshort\n16\n2\n0\n-32768~32767\n\n\nint\n32\n4\n0\n-2147483648~2147483647\n\n\nlong\n64\n8\n0L\n-92233372036854775808~9223372036854775807\n\n\nchar\n16\n2\n‘u0000’\n0~65535\n\n\nfloat\n32\n4\n0f\n1.4E-45~3.4028235E38\n\n\ndouble\n64\n8\n0d\n4.9E-324~3.4028235E38\n\n\nboolean\n1\n\nfalse\ntrue、false\n\n\n\n\nJava的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化二变化。\nchar a =  &#39;h&#39; char单引号，String a = &#39;hello&#39; 双引号\n包装类型不赋值就是Null，而基本类型有默认值且不是Null\n基本数据类型直接存放在Java虚拟机栈种的局部变量表种，而包装类型属于对象类型，我们指导对象实例都存在堆中。\n\n\n\n包装类型的常量池技术了解么？自我理解2022-03-28\n有些基本数据类型对应的包装类型都有常量池，如Byte、Short、Character (Integer)、Long 的常量池范围是-128 ~ 127。Char (Character)的常量池范围是：0 ~ 127。(Boolean 直接返回true or false而浮点数的包装类是没有常量池的。\nInteger i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false\n\n\n常量池中的比较是用的equals()\n官方理解Integer缓存源码\npublic static Integer valueOf(int i)&#123;\tif(i &gt;= IntegerCache.low &amp;&amp; i&lt;= IntegerCache.high)\t\treturn IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);\t&#125;\tprivate static class IntegerCache &#123;\t    static final int low = -128;\t    static final int high;\t    static &#123;\t        // high value may be configured by property\t        int h = 127;\t&#125;&#125;\n\nCharcter缓存源码\npublic static Character valueOf(char c) &#123;    if (c &lt;= 127) &#123; // must cache      return CharacterCache.cache[(int)c];    &#125;    return new Character(c);&#125;private static class CharacterCache &#123;    private CharacterCache()&#123;&#125;    static final Character cache[] = new Character[127 + 1];    static &#123;        for (int i = 0; i &lt; cache.length; i++)            cache[i] = new Character((char)i);    &#125;&#125;\n\nBoolean缓存源码\npublic static Boolean valueOf(boolean b) &#123;    return (b ? TRUE : FALSE);&#125;\n\n下面我们来看一下问题。下面的代码的输出结果是 true 还是 false 呢？\nInteger i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false\n\n\nInteger i1 = 40 这一行代码会发生装箱，也就是说这行代码等价于Integer i1 = Integer.valueOf(40)。因此，i1直接使用的是常量池中的对象。而Integer i2 = new Integer(40)会直接创建新的对象。\n\n如果超出对应范围仍然去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n所有整形包装对象之间值的比较，全部使用equals()方法比较\n\n\n\n自动装箱与拆箱了解吗？原理是什么？自我理解2022-03-28\n装箱：将基本数据类型的值用包装类 (用对应的引用类型)包装起来拆箱：将包装类转化为基本数据类型建议还是不要频繁使用，否则会增加系统负担。\n官方理解Integer num = 10; //自动装箱，没有通过new方法实现Integer num2 = new Integer(10); //非自动装箱\n\n\n\n引入包装类的就是提供一种机制，使得基本数据类型可以与引用数据类型相互转换\n装箱的过程是调用valueOf方法实现的\n拆箱过程是通过包装类的xxxValue方法实现的（xxx待变对应的基本数据类型类型\n自动装箱、自动拆箱：基本数据类型的自动装箱(boxing)拆箱(unboxing)自JDK5开始提供的功能。\nJava对于自动装箱和拆箱的设计，依赖于享元模式的设计模式\n\n\n\n参考文献Java基础常见知识&amp;面试题总结(上) | JavaGuide\n","categories":["Java"],"tags":["JavaGuide"]},{"title":"【LeetCode】26.删除排序数组中的重复项","url":"/2022/03/25/%E3%80%90LeetCode%E3%80%9126.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","content":"题目给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123;    assert nums[i] == expectedNums[i];&#125;\n\n如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n\n输入：nums = [1,1,2]输出：2, nums = [1,2,_ ]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n  0 &lt;= nums.length &lt;= 3 * 104\n  -104 &lt;= nums[i] &lt;= 104\n  nums 已按 升序 排列\n\n抄写JavaScriptvar removeDuplicates = function(nums)&#123;\tconst n = nums.length;\tif(n === 0)&#123;\t\treturn 0;\t&#125;\tlet fast = 1,slow = 1;\twhile(fast &lt; n)&#123;\t\tif(nums[fast] !== nums[fast-1])&#123;\t\t\tnums[slow] = nums[fast];\t\t\t++slow;\t\t&#125;\t\t++fast;\t&#125;\treturn slow&#125;\n\n\n\nJavaclass Solution&#123;\tpublic int removeDuplicates(int[] nums)&#123;\t\tint num = nums.length;\t\tint fast = 1,slow = 1;\t\tif(num == 0)&#123;\t\t\treturn 0;\t\t&#125;\t\twhile(fast &lt; num)&#123;\t\t\tif(nums[fast] != nums[fast-1])&#123;\t\t\t\tnums[slow] = nums[fast];\t\t\t\t++slow;\t\t\t&#125;\t\t\t++fast;\t\t&#125;\t\t\t\treturn slow;\t\t\t&#125;&#125;\n\n\n","categories":["LeetCode"],"tags":["刷题","LeetCode","删除重复项"]},{"title":"【LeetCode】27.移除元素","url":"/2022/03/24/%E3%80%90LeetCode%E3%80%9127.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","content":"题目27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:\n// **nums** 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 **该长度范围内** 的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n\n示例 1：\n\n输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n示例 2：\n\n输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n  0 &lt;= nums.length &lt;= 100\n  0 &lt;= nums[i] &lt;= 50\n  0 &lt;= val &lt;= 100\n\n\n抄写JavaScriptvar removeElement = function(nums,val)&#123;\tconst n = nums.length;\tlet left = 0;\t\tfor(let right = 0;right &lt; n;right++)&#123;\t\t\tif(nums[right] != val)&#123;\t\t\t\tnums[left] = nums[right];\t\t\t\tleft++;\t\t     &#125;\t\t&#125;\t return left;&#125;;\n\nJavaclass Solution&#123;\tpublic int removeElement(int[] nums,int val )&#123;\t\tint n = nums.length;\t\tint left = 0;\t\tfor(int right = 0;right &lt; n;right++)&#123;\t\t\tif(nums[right] != val)&#123;\t\t\t\tnums[left] = nums[right];\t\t\t\tleft++;\t\t\t\t&#125;\t\t\t&#125;\t return left;\t&#125;&#125;\n\n\n相关题目推荐\n  26.删除排序数组中的重复项\n\n 283.移动零\n\n  [[844.比较含退格的字符串]]\n\n  [[977.有序数组的平方]]\n\n\n","categories":["LeetCode"],"tags":["刷题","LeetCode","移除元素"]},{"title":"【LeetCode】283.移动零","url":"/2022/03/25/%E3%80%90LeetCode%E3%80%91283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/","content":"题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n\n输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]\n\n示例 2:\n\n输入: nums = [0]输出: [0]\n\n提示:\n\n  1 &lt;= nums.length &lt;= 104\n  -231 &lt;= nums[i] &lt;= 231 - 1\n\n抄写JavaScriptvar moveZeroes = function(nums)&#123;\tlet left = 0;right = 0;a = 0;\tconst n = nums.length;\twhile(right &lt; n)&#123;\t\tif(nums[right] !== 0)&#123;\t\t\ta = nums[left];\t\t\tnums[left] = nums[right];\t\t\tnums[right] = a;\t\t\t++left;\t\t&#125;\t\t++right;\t&#125;&#125;\n\nJavaclass Solution&#123;\tpublic Void moveZeroes(int[] nums)&#123;\t\tint left = 0,right = 0,a =0;\t\tint n = nums.length;\t\twhile(right&lt;n)&#123;\t\t\tif(nums[right] != 0)&#123;\t\t\t\ta=nums[left];\t\t\t\tnums[left] = nums[right];\t\t\t\tnums[right] = a;\t\t\t\t++left;\t\t\t&#125;\t\t++right;\t\t&#125;\t&#125;&#125;\n\n\n官方解答上面是我自己想出来的代码哦，虽然思路还是参照了官方写法哈哈哈哈这里贴一下官方解答，他是单独写了一个交换函数。\nclass Solution&#123;\tpublic void moveZeroes(int[] nums)&#123;\t\tint n = nums.length,left = 0,right = 0;\t\twhile(right &lt; n)&#123;\t\t\tif(nums[right] != 0)&#123;\t\t\t\tswap(nums,left,right);\t\t\t\tleft++;\t\t\t&#125;\t\t\tright++;\t\t&#125;\t&#125;\tpublic void swap(int[] nums,int left, int right)&#123;\t\tint temp = nums[left];\t\tnums[left] = nums[right];\t\tnums[right] = temp;\t&#125;&#125;\n","categories":["LeetCode"],"tags":["刷题","LeetCode","移除元素"]},{"title":"【chatApp解析】build.gradle(Module)","url":"/2022/04/09/%E3%80%90chatApp%E8%A7%A3%E6%9E%90%E3%80%91build.gradle(Module)/","content":"导语：内含buildFeatures、viewBinding、SDP、SSP、RoundImageView、MultDex\n#buildFeatures #viewBinding\n代码buildFeatures&#123;   viewBinding true  &#125;  buildToolsVersion &#x27;32.0.0&#x27;\n\n\nBuildFeatures官方文档BuildFeatures\n\nFlag to enable View Binding.Setting the value to null resets to the default value. Default value is false.You can override the default for this for all projects in your build by adding the line android.defaults.buildfeatures.viewbinding=true in the gradle.properties file at the root project of your build.More information about this feature at: TBD\n\n==总结==    用来构建功能列表，viewBinding(视图绑定)是其中一种方法\nviewBinding官方文档viewBinding\n主要内容摘要怎样产生作用的\n在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。在大多数情况下，视图绑定会替代 findViewById。\n\n生成绑定类时如何忽略某个布局文件如果您希望在生成绑定类时忽略某个布局文件，请将 tools:viewBindingIgnore=&quot;true&quot; 属性添加到相应布局文件的根视图中：\n&lt;LinearLayout\t\t\t...            \t\t\ttools:viewBindingIgnore=&quot;true&quot; &gt;        \t\t...    \t&lt;/LinearLayout&gt;    \n\n具体用法（Activity)假如有一个这样的布局文件result_profile.xml：\n&lt;LinearLayout ... &gt;        \t\t&lt;TextView android:id=&quot;@+id/name&quot; /&gt;        \t\t&lt;ImageView android:cropToPadding=&quot;true&quot; /&gt;        \t\t&lt;Button android:id=&quot;@+id/button&quot; \t\t\tandroid:background=&quot;@drawable/rounded_button&quot; /&gt;    &lt;/LinearLayout&gt;    \n\n所生成的绑定类的名称就为 ResultProfileBinding。此类具有两个字段：一个是名为 name 的 TextView，另一个是名为 button 的 Button。该布局中的 ImageView 没有 ID，因此绑定类中不存在对它的引用。\n在 Activity 中使用视图绑定 private ResultProfileBinding binding;   @Override  protected void onCreate(Bundle savedInstanceState) &#123;\tsuper.onCreate(savedInstanceState); \t//调用生成的绑定类中包含的静态 `inflate()` 方法。此操作会创建该绑定类的实例以供 Activity 使用\tbinding = ResultProfileBinding.inflate(getLayoutInflater()); \t//1.  通过调用 `getRoot()` 方法或使用 [Kotlin 属性语法]获取对根视图的引用。\tView view = binding.getRoot(); \t//1.  将根视图传递到 [`setContentView()`]，使其成为屏幕上的活动视图。\tsetContentView(view);  \t&#125;\n\n使用binding.getName().setText(viewModel.getName());binding.button.setOnClickListener(new View.OnClickListener() &#123; \tviewModel.userClicked()   \t&#125;);\n\nSDP and SSP//scalable size unit  implementation &#x27;com.intuit.sdp:sdp-android:1.0.6&#x27;  implementation &#x27;com.intuit.ssp:ssp-android:1.0.6&#x27;\n\nSDPSDP - a scalable size unit\n\nAn android lib that provides a new size unit - sdp (scalable dp). This size unit scales with the screen size. It can help Android developers with supporting multiple screens.for text views please refer to ssp which is based on the sp size unit for texts.\n\n总结：就是一个可伸缩的尺寸单位\nSSPSSP - a scalable size unit for texts\n\nAn android lib that provides a new size unit - ssp (scalable sp). This size unit scales with the screen size based on the sp size unit (for texts). It can help Android developers with supporting multiple screens.This is the sibling of the sdp size unit that should be used for non text views.\n\n总结：就素一个用于text的可扩展（可伸缩）的尺寸单位\nRoundedImageview[RoundedImageView]https://github.com/vinc3m1/RoundedImageView\nimplementation &#x27;com.makeramen:roundedimageview:2.3.0&#x27;\n\n\nA fast ImageView (and Drawable) that supports rounded corners (and ovals or circles) based on the original example from Romain Guy. It supports many additional features including ovals, rounded rectangles, ScaleTypes and TileModes.\n\n总结：是一个快速生成各种椭圆啊、圆角的东西，作者自称是Android最棒的圆角生成器（狗头）\nMultDex为方法数超过 64K 的应用启用 MultiDex\n//MultDex  implementation &#x27;androidx.multidex:multidex:2.0.1&#x27;\n\nAndroid 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536，其中包括 Android 框架方法、库方法以及您自己的代码中的方法。在计算机科学领域内，术语千（简称 K）表示 1024（即 2^10）。由于 65536 等于 64 X 1024，因此这一限制称为“64K 引用限制”\n如果您的 minSdkVersion 为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库\n小问题\n getName 是啥？\n\n","categories":["项目学习"],"tags":["Android","即时通讯","拉项目"]},{"title":"【LeetCode】704.二分查找","url":"/2022/03/23/%E3%80%90LeetCode%E3%80%91704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n\n输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4\n\n示例 2:\n\n输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1\n\n提示：\n\n 你可以假设 nums 中的所有元素是不重复的。\n n 将在 [1, 10000]之间。\n nums 的每个元素都将在 [-9999, 9999]之间。\n\n\n抄写// 定义函数 函数名 需要传入的参数：数组和目标值var search = function(nums,target)&#123;\t\t// 确定数组的最小下标和最大下标\tlet low = 0,high = nums.length - 1;\t//当数组有效时\t\twhile (low &lt;= high)&#123;\t\t\t//Math.floor()为向下取整\t\t\tconst mid = Math.floor((hign - low) / 2) + low;\t\t\t//用num取出中间值的具体值\t\t\tconst num = nums[mid];\t\t\t//当中间值和目标值相等时\t\t\tif(num === target)&#123;\t\t\t\t//返回中间值的下标\t\t\t\treturn mid;\t\t\t&#125; else if(num &gt; target)&#123;\t\t\t\t//中间值大于目标值时，需要在中间值的左边区间\t\t\t\t\t\t\thigh = mid -1;\t\t\t\t\t\t\t\t&#125; else &#123;\t\t\t\tlow = mid + 1;\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\treturn -1;&#125;\n\n\n\nclass Solution&#123;\tpublic int search(int[] nums, int target)&#123;\t\tint low = 0,high = nums.length-1;\t\twhile(low &lt;= high)&#123;\t\t\tint mid = (high - low)/2 + low;\t\t\tint num = nums[mid];\t\t\tif (num == target)&#123;\t\t\t\treturn mid;\t\t\t\t\t&#125;else if(num &gt; target)&#123;\t\t\t\thigh = mid -1;\t\t\t\t\t\t\t\t\t&#125;else&#123;\t\t\t\tlow = mid +1;\t\t\t&#125;\t\t\t&#125;\t\treturn -1;\t\t&#125;&#125;\n\n\n","categories":["LeetCode"],"tags":["刷题","LeetCode","二分查找"]},{"title":"【chatApp解析】values文件夹","url":"/2022/04/10/%E3%80%90chatApp%E8%A7%A3%E6%9E%90%E3%80%91values%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"导语：老实说，这部分没什么好解读的。大家看看就好^-^\ncolors.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;resources&gt;      &lt;color name=&quot;primary&quot;&gt;#1C2E46&lt;/color&gt;      &lt;color name=&quot;primary_dark&quot;&gt;#142232&lt;/color&gt;      &lt;color name=&quot;primary_text&quot;&gt;#212121&lt;/color&gt;      &lt;color name=&quot;secondary_text&quot;&gt;#757575&lt;/color&gt;      &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;      &lt;color name=&quot;input_background&quot;&gt;#ECECEC&lt;/color&gt;      &lt;color name=&quot;Icon_background&quot;&gt;#20FFFFFF&lt;/color&gt;      &lt;color name=&quot;error&quot;&gt;#800020&lt;/color&gt;      &lt;color name=&quot;received_message_background&quot;&gt;#090D16&lt;/color&gt;  &lt;/resources&gt;\n\nstrings.xml&lt;resources&gt;      &lt;string name=&quot;app_name&quot;&gt;ChatApp&lt;/string&gt;      &lt;string name=&quot;welcome_back&quot;&gt;welcome back&lt;/string&gt;      &lt;string name=&quot;log_to_continue&quot;&gt;Log to continue&lt;/string&gt;      &lt;string name=&quot;email&quot;&gt;email&lt;/string&gt;      &lt;string name=&quot;password&quot;&gt;Password&lt;/string&gt;      &lt;string name=&quot;sign_in&quot;&gt;Sign In&lt;/string&gt;      &lt;string name=&quot;create_new_account&quot;&gt;Create New Account&lt;/string&gt;      &lt;string name=&quot;add_image&quot;&gt;Add Image&lt;/string&gt;      &lt;string name=&quot;name&quot;&gt;Name&lt;/string&gt;      &lt;string name=&quot;confirm_password&quot;&gt;Confirm Password&lt;/string&gt;      &lt;string name=&quot;sign_up&quot;&gt;Sign Up&lt;/string&gt;      &lt;string name=&quot;select_users&quot;&gt;Select Users&lt;/string&gt;      &lt;string name=&quot;type_a_message&quot;&gt;说点什么吧~&lt;/string&gt;  &lt;/resources&gt;\n\nthemes.xml&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;      &lt;!-- Base application theme. --&gt;      &lt;!--NoActionBar就是不要app顶部的标题栏（写着App的名字）--&gt; &lt;style name=&quot;Theme.ChatApp&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;          &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt;          &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;@color/primary&lt;/item&gt;      &lt;/style&gt;  &lt;/resources&gt;\n\nthemes.xml(night)&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;      &lt;!-- Base application theme. --&gt;   &lt;style name=&quot;Theme.ChatApp&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;          &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt;          &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;@color/primary&lt;/item&gt;      &lt;/style&gt;  &lt;/resources&gt;\n","categories":["项目学习"],"tags":["Android","即时通讯","拉项目"]},{"title":"【一周总结】在Android Studio使用中遇到的问题及解决方法","url":"/2022/03/28/%E3%80%90%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91%E5%9C%A8Android%20Studio%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"就是在安装Android Studio阿里云依赖遇到的一些问题。比如在哪里安装依赖？安装哪些依赖？为什么会报错？\n在哪里安装依赖由于Android Studio最新版中gradle文件夹结果和内容做了一些修改，现在网上的教程大多不适用了，具体可以参考我的文章：Android Studio(2021.1.1)安装阿里云镜像\n安装哪些依赖具体解答如下：\nmaven &#123; url &#x27;https://maven.aliyun.com/nexus/content/groups/public/&#x27;&#125;  maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;  maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/google&#x27;&#125;  maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;\n\n为什么会报错？如果您是参照网上的旧教程导入的依赖可能会产生如下错误：\nCould not resolve all dependencies for configuration &#x27;:detachedConfiguration7&#x27;.Using insecure protocols with repositories, without explicit opt-in, is unsupported. Switch Maven repository &#x27;maven(http://maven.aliyun.com/nexus/content/groups/public/)&#x27; to redirect to a secure protocol (like HTTPS) or allow insecure protocols. See https://docs.gradle.org/7.0.2/dsl/org.gradle.api.artifacts.repositories.UrlArtifactRepository.html#org.gradle.api.artifacts.repositories.UrlArtifactRepository:allowInsecureProtocol for more details.\n\n这是什么意思呢？就是说你得把http 换成 https 就行啦。具体解答链接如下：Gradle报错Could not resolve all dependencies for configuration ‘:detachedConfiguration7‘._qq_41053520的博客-CSDN博客\n","categories":["一周总结"],"tags":["Android Studio","Android"]},{"title":"【一周总结】在hexo使用中遇到的问题及解决方法","url":"/2022/03/28/%E3%80%90%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91%E5%9C%A8hexo%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"摘要：git像github提交代码增加了access token的新要求。找不到git这个库怎么办呢？添加了access token还是push不到github上是怎么回事呢？为什么会提示No such remote &#39;origin&#39; ?\n问题1 access tokenremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: Authentication failed for &#x27;https://github.com/myownlili/myownlili.github.io/&#x27;FATAL &#123;  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (D:\\blog\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21)      at ChildProcess.emit (events.js:315:20)      at ChildProcess.cp.emit (D:\\blog\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)      at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12) &#123;    code: 128  &#125;&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html\n\n解决方法就是github要求使用token来进行更安全的代码推送，具体解决方法如下链接：关于Support for password authentication was removed on August 13, 2021报错的解决方案 - 知乎 (zhihu.com)\n问题2 找不到git这个库fatal: not a git repository (or any of the parent directories): .git\n解决方法说找不到git这个库，在命令行 输入 git init  然后回车就好了。具体解决方法如下链接：解决 fatal: Not a git repository (or any of the parent directories): .git 问题_蜗牛有力量的博客-CSDN博客\n问题3 No such remote ‘origin’$ git remote set-url origin https://[我的token]@github.com/myownlili/myownlili.github.io.gitfatal: No such remote &#x27;origin&#x27;\n\n解决方法增加一个远程url git remote add origin “xxx.git”即可。具体解决方法如下链接：git remote set-url origin “xxx.git“ 报错 No such remote ‘origin‘_子醉的博客-CSDN博客\n","categories":["一周总结"],"tags":["hexo","github"]},{"title":"你好世界","url":"/2023/04/23/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/","content":"让我们重新开始吧！！\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"八月燥热记","url":"/2020/08/10/%E5%85%AB%E6%9C%88%E7%87%A5%E7%83%AD%E8%AE%B0/","content":"学习启动计划及近日小结2020.08.10很久没有发文了，这里主要对近期生活做一些总结，以及开始学习微信小程序打算。\n\n学习启动计划 ：陆续学习一些计算机知识，本次学习的内容是微信小程序。俗话说，在哪里跌倒就在哪里爬起，我不能永远逃避。战胜懦弱的自己吧\n近日小结 ：主要对网站的一些变化进行记录\n微信小程序 ：坚持每天打卡学习微信小程序知识，那个coding game要不也尝试一下？\n\n\n近日小结\n加油！加油！加油！\n\n\n 网站被墙了！！\n\n太久没更新，再次上站时竟然被墙了…..遂更改本博客为github和Coding双部署。双部署后博客的响应速度令人感动，从未如此丝滑过\n\n 上传图片\n\n几十天前本站更新了一篇童年回忆-一些历史网站发现图都挂了。在查阅资料后成功实现图片上传，不容易啊\n微信小程序坚持每天学习打卡吧。。\n","categories":["日常"],"tags":["小结","学习打卡"]},{"title":"微信小程序1","url":"/2020/08/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F1/","content":"\n视频课程：【WEB前端】零基础玩转微信小程序\n\n微信小程序-1原生框架的目录结构\npages\nindex：存放首页的页面文件\nindex.js ：逻辑\nindex.json：配置项\nindex.wxml：便签嵌套\nindex.wxss：样式\n\n\nlogs：日志页面相关文件\n\n\nutils：可要可不要，帮助文档相关JS\napp.js：本小程序的入口文件和全局文件\napp.json：全局配置文件，如整个项目的标题名称\napp.wxss:全局样式文件\nproject.config.json：基础配置、环境配置\nsitemap.json：配置小程序及其页面是否循序被微信索引小程序配置文件app.json“pages”\n本小程序有哪些页面一 一对应pages文件夹中的路径 \n\n“window”\n定义小程序所有页面的顶部背景颜色、文字颜色定义等\n\n\nbackgroundTextstyle ：下拉刷新的所展现的文字颜色\nnavigationBarBackgroundColor ：导航栏背景颜色\nnavigationBarTitleText ：导航栏标题名称\nnavigationBarTextstyle ：导航栏文字颜色（black or white）\nenablePullDownRefresh ：全局下拉刷新\n\nenablePullDownRefresh:true\n  -backgroundColor  ：下拉刷新页面的背景颜色\n“tabbar”类似淘宝底部页面的切换在app.josn中添加：输入tabBar回车自动生成如下代码\n&quot;tabBar&quot;: &#123;    &quot;list&quot;: [&#123;      &quot;pagePath&quot;: &quot;,&quot;, //要跳转页面的页面路径      &quot;text&quot;: &quot;text&quot;, //标题      &quot;iconPath&quot;: &quot;iconPath&quot;, //未选中图标      &quot;selectedIconPath&quot;: &quot;selectedIconPath&quot; //已选中图标    &#125;]  &#125;\n&lt;app.josn&gt;如何改变此处标题颜色？在list的同级下编写\n&quot;tabBar&quot;: &#123;  &quot;list&quot;: [&#123;    ...  &#125;],  &quot;color&quot;:&quot;#0094ff&quot;,  &quot;selectedColor&quot;: &quot;#000000&quot;//只能使用16进制&#125;\n&lt;app.josn&gt;如何改变相对位置？\n&quot;tabBar&quot;: &#123;  &quot;list&quot;: [&#123;...&#125;],  &quot;color&quot;:&quot;#0094ff&quot;,  &quot;selectedColor&quot;: &quot;#000000&quot;,  &quot;position&quot;:&quot;top&quot; //未设置的话默认在bottom，tabbar在顶部时默认不显示图标&#125;\n&lt;app.josn&gt;\npage.json\n独立定义每一个页面的一些属性，如颜色等\n\npage.json用法与app.json中的Windo类似，其他使用参考小程序文档\nsitemap.json\n了解即可\n\n模板语法数据绑定\n\n\n标签\n作用\n\n\n\ntext\n行内标签，默认不换行\n\n\nview\n块级标签，默认换行\n\n\n页面中显示的数据放在目标页面/XXX.js的data中\n// pages/test/test.jsPage(&#123;    data: &#123;\tmsg:&quot;hello!world&quot;,\tnum:10000,\tisBoy:false，\tperson:&#123;\t\tage:74,\t\theight:145,\t\tweight:45, \t\tname:&quot;小王&quot;    &#125;,    ischecked:false&#125;)\ntest.wxml\n运算1.数字加减2.字符串拼接3.三元表达式\n数组和对象循环列表循环wx:for=“”wx:for-item=”循环项的名称”wx:for-index=”循环项的索引”\n// pages/test/test.jsPage(&#123;    data: &#123;        list:[            &#123;                id:0,                name:&quot;小李&quot;            &#125;,            &#123;                id:1,                name:&quot;amy&quot;            &#125;,            &#123;                id:3,                name:&quot;tony&quot;            &#125;        ]    &#125;&#125;)\n&lt;view&gt;    &lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;     wx:for-item=&quot;item&quot;     wx:for-index=&quot;index&quot;&gt;    索引：&#123;&#123;index&#125;&#125;    --    值：&#123;&#123;item.name&#125;&#125;    &lt;/view&gt;&lt;/view&gt;\nwx:key=”唯一的值”提高列表渲染的性能1 wx:key 绑定个普通的字符串的时候 那么这个字符串名称肯定是循环数组中的对象的 唯一属性2 wx:key =&quot;*this&quot; 就表示I你的数组是一个普通的数组 *this 表示是循环项普通数组[1,2,3,44,5]\n&lt;view&gt;    &lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;     wx:for-item=&quot;item&quot;     wx:for-index=&quot;index&quot;    wx:key=&quot;id&quot;&gt;    索引：&#123;&#123;index&#125;&#125;    --    值：&#123;&#123;item.name&#125;&#125;    &lt;/view&gt;&lt;/view&gt;\n3当出现数组的嵌套循环的时候尤其要注意 以下绑定的名称不要重名wx:for- item=”item&quot; wx : for- index=”index&quot;4默认情况下我们不写Wx: for- item=&quot; item&quot; WX : for - index=”index&quot;小程序也会把循环项的名称和索引的名称item 和index只有一层循环的话(wx :for item=&quot; item&quot; wx: for- index=&quot;index&quot;) 可以省略\n对象循环Wx :for=&quot;&#123;&#123;对象&#125;&#125;&quot; wx:for-item=&quot;对 象的值&quot; wX : for- index=&quot;对象的属性”==循环对象的时候最好把item和index的名称都修改一下==wx: for-item= “value”WX : for- index= “key’\n&lt;view&gt;    &lt;view&gt;对象循环&lt;/view&gt;    &lt;view wx:for=&quot;&#123;&#123;person&#125;&#125;&quot;     wx:for-item=&quot;value&quot;     wx:for-index=&quot;key&quot;    wx:key=&quot;age&quot;&gt;        属性：&#123;&#123;key&#125;&#125;        --        值：&#123;&#123;value&#125;&#125;    &lt;/view&gt;&lt;/view&gt;\n\n\n","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序2","url":"/2020/08/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F2/","content":"\n**视频课程：【WEB前端】零基础玩转微信小程序\n\n微信小程序-21 条件渲染\n当标签不是平凡切换显示，优先使用wx:if;频繁切换使用hidden\n\n1.1 wx:if\n1.2 hidden1.在标签中直接加入属性：hidden2.hidden=&quot;&#123;&#123;true&#125;&#125;&quot;3.hidden属性不要和样式display一起使用\n2 事件绑定1 需要给input标签绑定input事件绑定关键字bindinput2 如何获取输入框的值通过事件源对象来扶取e.detail.value3 把输入框的值赋值到data当中正确的写法\nthis setData(&#123;num:e.detai1.value)) \n4 需要加入一个点击事件\n\nbindtap\n无法在小程序当中的事件中直按传参\n通过白定义属性的方式来传递参数\n事件源中获取自定义属性Page(&#123;    data: &#123;        num:0    &#125;,    //输入框input事件的执行    handleinput(e)&#123;        this.setData(&#123;                num:e.detail.value        &#125;)    &#125;,    handletap(e)&#123;        console.log(e)        const operation=e.currentTarget.dataset.operation;        this.setData(&#123;            num:this.data.num+operation    &#125;)    &#125;,\n\n3 样式wxss3.1 导入\n引入的代码是通过 @import来引入\n路径 只能写相对路径@import&quot;../../styles/common.wxss&quot;;\n4 选择器与less\n略*5 常见组件5.1 view\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\nhover-class\nstring\nnone\n否\n指定按下去的样式类。当 hover-class=”none” 时，没有点击态效果\n\n\nhover-stop-propagation\nboolean\nfalse\n否\n指定是否阻止本节点的祖先节点出现点击态\n\n\nhover-start-time\nnumber\n50\n否\n按住后多久出现点击态，单位毫秒\n\n\nhover-stay-time\nnumber\n400\n否\n手指松开后点击态保留时间，单位毫秒\n\n\n\n\n5.2 text1.文本标签2只能嵌喜text3.长技文字可以复制(有该标签有这个功能)4.可以对空格回车进行编码\n\n\n\n属性\n类型\n默认值\n必填\n\n\n\nselectable\nBoolean\nfalse\n文本是否可选\n\n\ndecode\nBoolean\nfalse\n是否解码\n\n\n","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序3","url":"/2020/08/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F3/","content":"\n视频课程：【WEB前端】零基础玩转微信小程序\n\n微信小程序-31 image图片标签\nsrc 指定路径\nmode 决定图片内容和图片标签宽高做适配\n\n\n\n\n值\n说明\n\n\n\nscaleToFill\n缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素\n\n\naspectFit(轮播图常用)\n缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。\n\n\naspectFill\n缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。\n\n\nwidthFix\n缩放模式，宽度不变，高度自动变化，保持原图宽高比不变\n\n\nheightFix\n缩放模式，高度不变，宽度自动变化，保持原图宽高比不变\n\n\ntop\n裁剪模式，不缩放图片，只显示图片的顶部区域\n\n\nbottom\n裁剪模式，不缩放图片，只显示图片的底部区域\n\n\ncenter\n裁剪模式，不缩放图片，只显示图片的中间区域\n\n\nleft\n裁剪模式，不缩放图片，只显示图片的左边区域\n\n\nright\n裁剪模式，不缩放图片，只显示图片的右边区域\n\n\ntop left\n裁剪模式，不缩放图片，只显示图片的左上边区域\n\n\ntop right\n裁剪模式，不缩放图片，只显示图片的右上边区域\n\n\nbottom left\n裁剪模式，不缩放图片，只显示图片的左下边区域\n\n\nbottom right\n裁剪模式，不缩放图片，只显示图片的右下边区域\n\n\n\n小程序中的图片支持懒加载 lazy_load\n\n&lt;image src=&quot;../image/333.jpg&quot; mode=&quot;widthFix&quot; lazy-load=&quot;&quot;&gt;&lt;/image&gt;\nimage&#123;    box-sizing: border-box;    border: 2px solid black;    height: 700rpx;    width: 350rpx;&#125;\n2 swiper轮播图组件\n先找出来原图的宽度和高度等比例给swiper 定宽度和高度原图的宽度和高度1125 * 352 pxswiper宽度/swiper高度=原图的宽度/原图的高度swiper高度 = swiper 宽度*原图的高度 /原图的宽度height: 100vw * 352 / 1125\n\n\nswiper&#123;     width:100%;     height: calc(100vw*394/640);&#125;image&#123;    width: 100%;&#125;\n\n\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\nindicator-dots\nboolean\nfalse\n否\n是否显示面板指示点\n\n\nindicator-color\ncolor\nrgba(0, 0, 0, .3)\n否\n指示点颜色\n\n\nindicator-active-color\ncolor\n#000000\n否\n当前选中的指示点颜色\n\n\nautoplay\nboolean\nfalse\n否\n是否自动切换\n\n\ninterval\nnumber\n5000\n否\n自动切换时间间隔\n\n\ncircular\nboolean\nfalse\n否\n是否采用衔接滑动\n\n\n\n3 navigator超链接标签\nurl 目标页面的路径\ntarget在那个目标上发生跳转，默认当前小程序，可选值self(默认自己）/miniProgram（其他小程序页面）\nopen-type跳转的方式\n\nopen-type 的合法值：\n\n\n\n值\n说明\n\n\n\nnavigate\n保留当前页面，跳转到应用内的某个页面，但是不能跳转到tabbbar页面\n\n\nredirect\n关闭当前页面，台哦转到应用内的某个页面，但是不允许跳转到tabbar页面\n\n\nswitchTab\n跳转到tabbar页面，并关闭其他非tabbar页面\n\n\nreLaunch\n关闭所有页面，打开应用内的某个页面\n\n\nnavigateBack\n关闭当前页面，返回上一页面或多级页面，可通过getCurrentPages()获取当前的页面栈，决定需要返回几层\n\n\nexit\n退出小程序target=”miniProgram”时生效\n\n\n","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序4","url":"/2020/08/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F4/","content":"\n视频课程：【WEB前端】零基础玩转微信小程序\n\n微信小程序-41 rich-text富文本标签\n标签字符串\n\n&lt;rich-text nodes=&quot;&#123;&#123;html&#125;&#125;&quot;&gt;&lt;/rich-text&gt;\n\n对象数组\n\nPage(&#123;    /**     * 页面的初始数据     */    data: &#123;        html:[            &#123;                //div标签 name属性来指定                name:&quot;div&quot;,                //标签有哪些属性                attrs:&#123;                    //标签的属性class style                    class:&quot;my_div&quot;,                    style:&quot;color:red;&quot;                &#125;,                //子节点children要接收的数据类型和nodes第二种渲染方式的数据类型一致                 children:[&#123;                      name:&quot;p&quot;,                    attrs:&#123; &#125;,                    //放文本                    children:[                        &#123;                            type:&quot;text&quot;,                            text:&quot;hello&quot;                        &#125;                    ]                &#125;                ]            &#125;        ]    &#125;&#125;)\n2 button2.1 外观属性\n\n\n属性\n类型\n默认值\n说明\n合法值\n\n\n\nsize\nstring\ndefault\n按钮的大小\ndefault：默认大小，mini：小尺寸\n\n\ntype\nstring\ndefault\n按钮的样式类型\nprimary    绿色    default    白色 warn    红色\n\n\nplain\nboolean\nfalse\n按钮是否镂空，背景色透明\n\n\n\ndisabled\nboolean\nfalse\n是否禁用\n\n\n\nloading\nboolean\nfalse\n名称前是否带 loading 图标\n\n\n\n代码：效果：\n2.2 开发能力2.2.1 open-typeopen-type 的合法值\n\n\n\n值\n说明\n\n\n\ncontact\n打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，具体说明\n\n\nshare\n触发用户转发，使用前建议先阅读使用指引\n\n\ngetPhoneNumber\n获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，具体说明\n\n\ngetUserInfo\n获取用户信息，可以从bindgetuserinfo回调中获取到用户信息\n\n\nlaunchApp\n打开APP，可以通过app-parameter属性设定向APP传的参数具体说明\n\n\nopenSetting\n打开授权设置页\n\n\nfeedback\n打开“意见反馈”页面，用户可提交反馈内容并上传日志，开发者可以登录小程序管理后台后进入左侧菜单“客服反馈”页面获取到反馈内容\n\n\n\nPage(&#123;    getphonenumber(e)&#123;        console.log(e);    &#125;,    getuserinfo(e)&#123;        console.log(e);    &#125;&#125;)\n\n3 icon|属性    |类型    |默认值    |必填    |说明||—|—|—|—|—|—||type    |string    |    |是    |icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear    ||size    |number/string    |23    |否    |icon的大小    ||color    |string    |    |否    |icon的颜色，同css的color    |\n代码：效果：\n4 radio 单选框\n必须与父元素 radio-group来使用\n需要给radio-group绑定change事件\n在页面中显示选中的值\n\n\n\n\n属性\n类型\n默认值\n说明\n\n\n\nvalue\nstring\n\nradio 标识。当该radio 选中时，radio-group 的 change 事件会携带radio的value\n\n\nchecked\nboolean\nfalse\n当前是否选中\n\n\ndisabled\nboolean\nfalse\n是否禁用\n\n\ncolor\nstring\n#09BB07\nradio的颜色，同css的color\n\n\nWXML代码：数据绑定：\n// pages/06/06.jsPage(&#123;    handlechange(e)&#123;        console.log(e.detail.value);        let num=e.detail.value        this.setData(&#123;            num        &#125;)    &#125;,    data: &#123;        num:&quot;&quot;    &#125;,&#125;)\n\n效果：\n5 checkbox复选标签WXML代码：数据绑定：\n// pages/07/07.jsPage(&#123;    handItemChange(e)&#123;        console.log(e)        const checkedList=e.detail.value;        this.setData(            &#123;                checkedList            &#125;        )    &#125;,    data: &#123;        list:[&#123;            id:0,            name:&quot;香蕉&quot;,            value:&quot;banana&quot;        &#125;,        &#123;            id:1,            name:&quot;苹果&quot;,            value:&quot;apple&quot;        &#125;,        &#123;            id:2,            name:&quot;葡萄&quot;,            value:&quot;grape&quot;        &#125;],        checkedList:[]    &#125;&#125;)\n效果：\n6 自定义组件1 新增组件：新建文件夹components-再其中新建文件夹Tabs(组件名)-右键Tabs,再选择新建Component2 新增页面：略3 连接：在新增的页面的json文件中编写如下代码\n&#123;  &quot;usingComponents&quot;: &#123;    &quot;Tabs&quot;:&quot;../../components/Tabs/Tabs&quot;  &#125;&#125;\n最后在新建页面的wxml文件中编写&lt;Tabs&gt;&lt;/Tabs&gt;查看是否连接成功\n6.1 小实践6.1.1 样式设计优化wxml代码\ndata: &#123;       tabs:[           &#123;               id:0,               name:&quot;首页&quot;,               isActive:true           &#125;,           &#123;               id:1,               name:&quot;原创&quot;,               isActive:false           &#125;,           &#123;               id:2,               name:&quot;分类&quot;,               isActive:false           &#125;,           &#123;               id:3,               name:&quot;关于&quot;,               isActive:false           &#125;       ]   &#125;,\n\n.tabs&#123;&#125;.tabs_title&#123;    display: flex;    padding: 10rpx;&#125;.title_item&#123;    flex: 1;    display: flex;    /* 文字水平对齐 */    justify-content: center;      /* 文字垂直对齐 */    align-items: center;&#125;/* 选中效果 */.active&#123;    color: blue;    border-bottom: 10rpx solid navy;&#125;.tabs_content&#123;&#125;\n效果：\n6.1.2 标题选中激活在组件.js中存放事件回调函数是在methods中\nwxml中的相关代码:\njs中相关代码:\nmethods: &#123;        handleItemTap(e)&#123;            console.log(e);            // 1 绑定点击事件            // 2 获取被点击的索引            // 3 获取原数组            // 4 对数组循环            //     1 对每一个循环项 选中属性 改为false            //     2 给当前的索引项添加激活选中效果            //获取索引            const &#123;index&#125;=e.currentTarget.dataset;            //获取data中的数组            //let tabs=this.data.tabs同样的效果            let &#123;tabs&#125;=this.data;            //4 循环数组            //[].forEach 遍历数组 遍历时，v被修改，也会导致原数组被修改            tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false);            this.setData(&#123;                tabs            &#125;)        &#125;    &#125;","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序5","url":"/2020/08/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F5/","content":"\n视频课程：【WEB前端】零基础玩转微信小程序\n\n微信小程序-51.父向子传递数据1.父组件（页面）向子组件传递数据使通过标签属性的方式传递的\n\n在子组件上进行接收\n把这个数据当成data中的数据即可\n\n08.wxml\n&lt;Tabs aaa=&quot;123&quot;&gt;&lt;/Tabs&gt;\nTab.js\nproperties: &#123;    // 要接收数据名称    aaa:&#123;        // type要接收的数组类型        type:String,        // value默认值        value:&quot;&quot;    &#125;&#125;,\nTabs.wxml\n\n删去Tabs.js中的tabs:[…]中的数据\n08.js\ndata: &#123;        tabs:[            &#123;                id:0,                name:&quot;首页&quot;,                isActive:true            &#125;,            &#123;                id:1,                name:&quot;原创&quot;,                isActive:false            &#125;,            &#123;                id:2,                name:&quot;分类&quot;,                isActive:false            &#125;,            &#123;                id:3,                name:&quot;关于&quot;,                isActive:false            &#125;        ]   &#125;\n08.wxml&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot;&gt;&lt;/Tabs&gt;\nTab.js\nproperties: &#123;        tabs:&#123;            type:Array,            value:[]        &#125;    &#125;,\n\n2 子向父传递数据\n点击事件触发后 触发父组件中的自定义事件 同时传递数据给父组件\n\n\n在子组件的标签上加入一个自定义事件\n\n08.wxml\nTab.js\nmethods: &#123;    handleItemTap(e)&#123;         const &#123;index&#125;=e.currentTarget.dataset;         this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;);    &#125;&#125;\n08.js/data\nhandleItemChenge(e)&#123;    // 接收传递过来的参数    const &#123;index&#125;=e.detail;    let &#123;tabs&#125;=this.data;    tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false);    this.setData(&#123;         tabs     &#125;)&#125;\n\n3 自定义组件-slot\nslot标签 其实是占位符或者插槽\n\n等到父组件调用子组件的时候再传递标签过来最终这些被传递的标签就会替换slot插槽的位置主要作用让每一页面显示不同的内容\n组件的其他属性\n\n\n定义段\n类型\n是否必填\n描述\n\n\n\nproperties\nObject Map\n否\n组件的对外属性，是属性名到属性设置的映射表\n\n\ndata\nObject\n否\n组件的内部数据，和properties一同用于组件的模板渲染\n\n\nobservers\nObject\n否\n组件数据字段监听器，用于监听properties和data的变化\n\n\nmethods\nObject\n否\n组件的方法，包括事件响应函数和任意的自定义方法\n\n\ncreated\nFunction\n否\n组件生命周期函数，在组件实例刚刚被创建时执行，注意此时不能调用setData\n\n\nattached\nFunction\n否\n组件生命周期函数，在组件实例进入页面节点树时执行\n\n\nready\nFunction\n否\n组件生命周期函数，在组件布局完成后执行,\n\n\nmoved\nFunction\n否\n组件生命周期函数，在组件实例被移动到节点树另一个位置执行\n\n\ndetached\nFunction\n否\n组件生命周期函数，在组件实例被从页面节点树移除时执行\n\n\n","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序6","url":"/2020/08/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F6/","content":"\n2020最新微信小程序开发零基础入门+项目案例【新视觉实训】\n\n微信小程序6-API篇1 Object wx.getSystemInfoSync()wx.getSystemInfoSync()官方文档\n\n\n\n属性\n类型\n说明\n\n\n\nbrand\nstring\n设备品牌\n\n\nmodel\nstring\n设备型号\n\n\npixelRatio\nnumber\n设备像素比\n\n\nscreenWidth\nnumber\n屏幕宽度，单位px\n\n\nscreenHeight\nnumber\n屏幕高度，单位px\n\n\nwindowWidth\nnumber\n可使用窗口宽度，单位px\n\n\nwindowHeight\nnumber\n可使用窗口高度，单位px\n\n\nstatusBarHeight\nnumber\n状态栏的高度，单位px\n\n\nlanguage\nstring\n微信设置的语言\n\n\nversion\nstring\n微信版本号\n\n\nsystem\nstring\n操作系统及版本\n\n\nplatform\nstring\n客户端平台\n\n\nonLoad: function (options) &#123;        console.log(wx.getSystemInfo())    &#125;,\n\n2 wx.showLoading(Object object)wx.showLoading官方文档\n注意\n\nwx.showLoading 和 wx.showToast 同时只能显示一个\nwx.showLoading 应与 wx.hideLoading 配对使用\n\nObject object\n\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\ntitle\nstring\n\n是\n提示的内容\n\n\nmask\nboolean\nfalse\n否\n是否显示透明蒙层，防止触摸穿透\n\n\nsuccess\nfunction\n\n否\n接口调用成功的回调函数\n\n\nfail\nfunction\n\n否\n接口调用失败的回调函数\n\n\ncomplete\nfunction\n\n否\n接口调用结束的回调函数（调用成功、失败都会执行）\n\n\nonLoad: function (options) &#123;        // console.log(wx.getSystemInfo())        wx.showLoading(&#123;          title: &#x27;加载中&#x27;,        &#125;)        setTimeout(function () &#123;            wx.hideLoading()          &#125;, 2000)    &#125;,\n\n3 wx.showToast(Object object)wx.showToast官方文档\nObject object\n\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\ntitle\nstring\n\n是\n提示的内容\n\n\nicon\nstring\n‘success’\n否\n图标\n\n\nimage\nstring\n\n否\n自定义图标的本地路径，image 的优先级高于 icon\n\n\nduration\nnumber\n1500\n否\n提示的延迟时间\n\n\nmask\nboolean\nfalse\n否\n是否显示透明蒙层，防止触摸穿透\n\n\nsuccess\nfunction\n\n否\n接口调用成功的回调函数\n\n\nfail\nfunction\n\n否\n接口调用失败的回调函数\n\n\ncomplete\nfunction\n\n否\n接口调用结束的回调函数（调用成功、失败都会执行）\n\n\nonLoad:function()&#123;    wx.showToast(&#123;        title: &#x27;终于成功&#x27;,        icon: &#x27;success&#x27;,        duration: 2000      &#125;)&#125;,\n\n\n","categories":["微信小程序"],"tags":["微信小程序"]},{"title":"微信小程序7","url":"/2020/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F7/","content":"小程序实践集合快递单号（有瑕疵）\n2020-08-18\n\n// pages/09/09.jsPage(&#123;    /**     * 页面的初始数据     */    data: &#123;        inputValue: &#x27;&#x27;,        searesult:&#x27;&#x27;    &#125;,    bindNumInput: function (e) &#123;        console.log(e.detail.value)        this.setData(&#123;            inputValue: e.detail.value          &#125;)      &#125;,    //   nu参数，cb方法    getExpressInfo:function()&#123;        let number = this.data.inputValue        wx.request(&#123;            url: &#x27;http://api.tianapi.com/txapi/kuaidi/index&#x27;, //仅为示例，并非真实的接口地址            method:&#x27;GET&#x27;,            data: &#123;              key: &#x27;********&#x27;,              number: number            &#125;,            success :(res)=&gt; &#123;              console.log(res.data)              this.setData(&#123;                searesult:res.data.msg              &#125;)            &#125;          &#125;)    &#125;,&#125;)\n\n.weui-cells__title&#123;    padding: 50rpx;&#125;input&#123;    border: solid black 2rpx;    padding: 20rpx;&#125;button&#123;    margin-top: 50rpx;    margin-left: 300rpx;&#125;.text&#123;    margin: 15rpx;    height: 700rpx;    width: 725rpx;    border: solid black 2rpx;&#125;\n\nwxml\n\n效果截图\n舔狗日记// pages/10/10.jsPage(&#123;    /**     * 页面的初始数据     */    data: &#123;        content:[]    &#125;,    createclick:function()&#123;        wx.request(&#123;            url: &#x27;http://api.tianapi.com/txapi/tiangou/index&#x27;, //仅为示例，并非真实的接口地址            data: &#123;              key: &#x27;09d5f0490a9f3044317b3b9a03fd16f0&#x27;,            &#125;,            success: (res)=&gt; &#123;                this.setData(&#123;                 content: res.data.newslist[0].content                &#125;)            &#125;          &#125;),          wx.showToast(&#123;            title: &#x27;成功&#x27;,            icon: &#x27;success&#x27;,            duration: 2000          &#125;)    &#125;,    /**     * 生命周期函数--监听页面加载     */    onLoad: function (options) &#123;        wx.showModal(&#123;            title: &#x27;爱的提示&#x27;,            content: &#x27;做自己的舔狗，让别人无处可舔&#x27;,            success (res) &#123;              if (res.confirm) &#123;                console.log(&#x27;用户点击确定&#x27;)              &#125; else if (res.cancel) &#123;                console.log(&#x27;用户点击取消&#x27;)              &#125;            &#125;          &#125;)    &#125;&#125;)\n\n.text&#123;    margin: auto;    height: 900rpx;    width: 700rpx;    border: black solid 5rpx;    background:#fffbf0;    border-radius:20rpx;    box-shadow: 10px 10px 5px #75878a;&#125;.no1&#123;    margin-top: 50rpx;    margin-left: 300rpx;&#125;.word&#123;    margin-top: 100rpx;    margin-left: 180rpx;&#125;\n\nwxml\n\n效果图\n\n","categories":["微信小程序"],"tags":["微信小程序","实践"]},{"title":"欢迎来到我的博客","url":"/2020/06/26/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"这是本人第一次搭建的博客搭建平台是github和Hexo(这不是重点)，网站模板也是套用的。。。不管，我安装的也算我搭建的了：)\n网站有很多功能并没有完善比如留言板还没有引进，RSS订阅也没搞（我也不知道这是什么）。界面设计也还有很多不满意的地方。\n关于网址在纠结要不要连一个域名，但是怕被攻击（菜鸡落泪）。\n最后很多操作还没熟悉，就先这样子吧。有时间继续搞。\n","categories":["日常"],"tags":["日常"]},{"title":"童年回忆-一些历史网站","url":"/2020/07/26/%E7%AB%A5%E5%B9%B4%E5%9B%9E%E5%BF%86-%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2%E7%BD%91%E7%AB%99/","content":"前记博主一直都很喜欢有着历史记忆的照片、视频,特别是八九十年代风格的。在逛虫部落时，看到一个帖子《1999 年创建的个人网站，至今仍在更新》（https://www.chongbuluo.com/thread-7894-1-1.html ）发现了一些有趣的网站，在这里我分享记录一些我喜欢的网站，更多内容请去原帖看看。怀恋那个野蛮生长的互联网时代\n阿江守护http://www.ajiang.net/index.html阿江守护-高校文学爱好者的乐园，看着作者1999年的文字，感觉有种跨越时空交谈的错觉。小时候还不会网上冲浪，等长大后再寻找当时的痕迹，感觉相当奇妙作者回复我的留言了呢，开心\n秘密花园http://www.yini.org/club/garden.html于1999年01月20日 建立，每个男孩都是一个亚当的故事，每个女孩都是一个夏娃的传说…秘密花园在我看来记录着一个少女的心思。另：网站作者的QQ居然是5位数的。该网站到现在的流量还挺惊人的，我都翻不到我六月中旬的留言了\n蜡笔xhttp://www.labix.net/labix.htm据说是一个全flash的网站，第一次打开真的很惊艳。在零几年曾有人这么用心的建造个人网站。该网站细节满满，大家可以找找有多少彩蛋。可惜Adobe宣布2020年12月31日就要停止flash更新，不知这网站何去何从。\n雨后池塘https://www.trueme.net/一个集知音体文学、早年QQ空间于一体的网站。博主截图的时候发现该网站的流量也挺多的。该网站还可以装扮自己的小屋，拜访其他人以及VIP小屋服务。还不快搞一个账号，就当自己的后花园了哈哈哈哈\n结束语博主一直有一个拥有个人博客的想法，在浏览了这样网站后才真的下定决心建立了《小李的博客》。大概在我还是小学初中的时候就沉迷于QQ空间。那时的QQ空间还可以养花，我有好多花花~还有飞信，我超级喜欢飞信的漂流瓶（？)功能，在漂流瓶里遇到很多有趣的人。也喜欢逛贴吧，不知道那时候算不算贴吧的鼎盛时期，反正很热闹就是了。高考前都是不能光明正大的玩手机，后来能自由玩手机了，发现记忆里很多东西都不见了。那时的网络，大家都保持着好奇，还有一股蜜汁自信；那时的网络阴阳怪气（我看到的）也很少……时光易逝啊，那些记忆里的东西都消失了，而我什么也留不住。\n","categories":["日常"],"tags":["怀旧","各种网站"]}]